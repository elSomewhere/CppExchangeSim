<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L3 Orderbook Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace;
            background-color: #111827;
            color: white;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .visualization {
            flex: 1;
            position: relative;
        }

        .controls {
            width: 320px;
            background-color: #1f2937;
            padding: 16px;
            overflow-y: auto;
        }

        .controls h2 {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 16px;
        }

        .controls h3 {
            font-weight: 600;
            margin-bottom: 12px;
        }

        .section {
            margin-bottom: 24px;
            padding: 12px;
            background-color: #374151;
            border-radius: 8px;
        }

        .stats-section {
            background-color: #374151;
        }

        .stat-item {
            margin-bottom: 4px;
            font-size: 14px;
        }

        .button {
            width: 100%;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .button-start {
            background-color: #059669;
            color: white;
        }

        .button-start:hover {
            background-color: #047857;
        }

        .button-stop {
            background-color: #dc2626;
            color: white;
        }

        .button-stop:hover {
            background-color: #b91c1c;
        }

        .button-reset {
            background-color: #2563eb;
            color: white;
        }

        .button-reset:hover {
            background-color: #1d4ed8;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: block;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .control-input {
            width: 100%;
            margin-bottom: 4px;
        }

        .control-hint {
            font-size: 12px;
            color: #9ca3af;
        }

        .legend {
            font-size: 14px;
            color: #d1d5db;
        }

        .legend-item {
            margin-bottom: 4px;
        }

        .text-yellow {
            color: #fbbf24;
        }

        .text-green {
            color: #10b981;
        }

        .border-top {
            border-top: 1px solid #4b5563;
            padding-top: 8px;
            margin-top: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="visualization" id="visualization"></div>

        <div class="controls">
            <h2>L3 Orderbook Controls</h2>

            <div class="section stats-section">
                <h3>Statistics</h3>
                <div id="stats">
                    <div class="stat-item">Events: <span id="events">0</span></div>
                    <div class="stat-item">Total Orders: <span id="totalOrders">0</span></div>
                    <div class="stat-item">Target Rate: <span id="targetRate">10</span> events/sec</div>
                    <div class="stat-item">Actual Rate: <span id="actualRate">0.0</span> events/sec</div>
                    <div class="border-top">
                        <div class="stat-item">Volume: B<span id="bidVolume">0</span> | A<span id="askVolume">0</span>
                        </div>
                        <div class="stat-item">Levels: B<span id="bidLevels">0</span> | A<span id="askLevels">0</span>
                        </div>
                        <div class="stat-item">Balance: <span id="balance">0.0</span>%</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>Simulation</h3>
                <button id="toggleBtn" class="button button-start">Start Simulation</button>
                <button id="resetBtn" class="button button-reset">Reset Orderbook</button>
            </div>

            <div class="section">
                <h3>Event Rate</h3>
                <div class="control-group">
                    <label class="control-label">Events per Second: <span id="eventsPerSecondValue">10</span></label>
                    <input type="range" id="eventsPerSecond" class="control-input" min="1" max="50" step="1" value="10">
                    <div class="control-hint">1 - 50 events/sec</div>
                </div>
            </div>

            <div class="section">
                <h3>Market Parameters</h3>
                <div class="control-group">
                    <label class="control-label">Mid Price: $<span id="midPriceValue">100.0</span></label>
                    <input type="range" id="midPrice" class="control-input" min="50" max="200" step="1" value="100">
                </div>
                <div class="control-group">
                    <label class="control-label">Target Spread: $<span id="spreadSizeValue">0.010</span></label>
                    <input type="range" id="spreadSize" class="control-input" min="0.001" max="0.1" step="0.001"
                        value="0.01">
                </div>
                <div class="control-group">
                    <label class="control-label">Min Spread: $<span id="minSpreadValue">0.005</span></label>
                    <input type="range" id="minSpread" class="control-input" min="0.001" max="0.05" step="0.001"
                        value="0.005">
                </div>
                <div class="control-group">
                    <label class="control-label">Max Price Levels: <span id="maxPriceLevelsValue">25</span></label>
                    <input type="range" id="maxPriceLevels" class="control-input" min="10" max="50" step="5" value="25">
                </div>
            </div>

            <div class="section">
                <h3>Order Sizes</h3>
                <div class="control-group">
                    <label class="control-label">Min Order Size: <span id="minOrderSizeValue">10</span></label>
                    <input type="range" id="minOrderSize" class="control-input" min="1" max="50" step="1" value="10">
                </div>
                <div class="control-group">
                    <label class="control-label">Max Order Size: <span id="maxOrderSizeValue">100</span></label>
                    <input type="range" id="maxOrderSize" class="control-input" min="50" max="500" step="10"
                        value="100">
                </div>
            </div>

            <div class="section">
                <h3>Balance Controls</h3>
                <div class="control-group">
                    <label class="control-label">Balance Strength: <span id="balanceStrengthValue">50</span>%</label>
                    <input type="range" id="balanceStrength" class="control-input" min="0" max="100" step="10"
                        value="50">
                    <div class="control-hint">How aggressively to balance sides</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Market Making: <span id="marketMakingWeightValue">10</span>%</label>
                    <input type="range" id="marketMakingWeight" class="control-input" min="0" max="30" step="2"
                        value="10">
                    <div class="control-hint">Frequency of balance-restoring orders</div>
                </div>
            </div>

            <div class="section">
                <h3>Event Probabilities (%)</h3>
                <div class="control-group">
                    <label class="control-label">Add Orders: <span id="addOrderWeightValue">50</span>%</label>
                    <input type="range" id="addOrderWeight" class="control-input" min="10" max="60" step="5" value="50">
                </div>
                <div class="control-group">
                    <label class="control-label">Cancel Orders: <span id="cancelOrderWeightValue">25</span>%</label>
                    <input type="range" id="cancelOrderWeight" class="control-input" min="10" max="40" step="5"
                        value="25">
                </div>
                <div class="control-group">
                    <label class="control-label">Fill Orders: <span id="fillOrderWeightValue">20</span>%</label>
                    <input type="range" id="fillOrderWeight" class="control-input" min="5" max="30" step="5" value="20">
                </div>
                <div class="control-group">
                    <label class="control-label">Market Sweeps: <span id="marketSweepWeightValue">5</span>%</label>
                    <input type="range" id="marketSweepWeight" class="control-input" min="1" max="15" step="1"
                        value="5">
                </div>
            </div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">üî¥ Red: Ask orders (sell)</div>
                <div class="legend-item">üîµ Blue: Bid orders (buy)</div>
                <div class="legend-item">[x,y,z]: Individual order sizes</div>
                <div class="legend-item">üí• Market sweeps consume levels</div>
                <div class="legend-item">‚öñÔ∏è Auto-balancing sides</div>
                <div class="legend-item">ü§ñ Market making for liquidity</div>
                <div class="legend-item">üìà Price discovery via imbalance</div>
                <div class="legend-item">‚è∞ Time decay removes old orders</div>
            </div>
        </div>
    </div>

    <script>
        // Global state variables
        let isRunning = false;
        let scene, renderer, camera, mount;
        let textObjects = [];
        let orderbook = null;
        let simulationTimeout = null;

        let stats = {
            events: 0,
            totalOrders: 0,
            actualRate: 0,
            lastRateUpdate: Date.now(),
            recentEvents: []
        };

        let settings = {
            eventsPerSecond: 10,
            spreadSize: 0.01,
            maxOrderSize: 100,
            minOrderSize: 10,
            addOrderWeight: 50,
            cancelOrderWeight: 25,
            fillOrderWeight: 20,
            marketSweepWeight: 5,
            midPrice: 100.0,
            maxPriceLevels: 25,
            minSpread: 0.005,
            balanceStrength: 50,
            marketMakingWeight: 10
        };

        // Generate Poisson-distributed intervals
        function generatePoissonInterval() {
            const lambda = settings.eventsPerSecond;
            return -Math.log(1 - Math.random()) / lambda * 1000;
        }

        // Calculate orderbook balance metrics
        function calculateBalance(orderbook) {
            const bidVolume = orderbook.bids.reduce((total, level) =>
                total + level.orders.reduce((sum, order) => sum + order.size, 0), 0);
            const askVolume = orderbook.asks.reduce((total, level) =>
                total + level.orders.reduce((sum, order) => sum + order.size, 0), 0);

            const bidLevels = orderbook.bids.length;
            const askLevels = orderbook.asks.length;

            const volumeImbalance = bidVolume - askVolume;
            const levelImbalance = bidLevels - askLevels;
            const totalVolume = bidVolume + askVolume;

            return {
                bidVolume,
                askVolume,
                bidLevels,
                askLevels,
                volumeImbalance,
                levelImbalance,
                volumeImbalanceRatio: totalVolume > 0 ? volumeImbalance / totalVolume : 0,
                levelImbalanceRatio: (bidLevels + askLevels) > 0 ? levelImbalance / (bidLevels + askLevels) : 0
            };
        }

        function getTotalOrders(orderbook) {
            return [...orderbook.bids, ...orderbook.asks]
                .reduce((total, level) => total + level.orders.length, 0);
        }

        // Create initial orderbook state
        function createInitialOrderbook() {
            const { midPrice, spreadSize, maxOrderSize, minOrderSize, maxPriceLevels } = settings;
            const orderbook = {
                bids: [],
                asks: [],
                nextOrderId: 1,
                midPrice: midPrice
            };

            // Create initial bid levels
            for (let i = 0; i < Math.min(maxPriceLevels, 20); i++) {
                const price = parseFloat((midPrice - spreadSize / 2 - i * 0.01).toFixed(3));
                const orders = [];
                const numOrders = Math.max(1, Math.floor(Math.random() * (5 - i * 0.2)));

                for (let j = 0; j < numOrders; j++) {
                    orders.push({
                        id: orderbook.nextOrderId++,
                        price: price,
                        size: Math.random() * (maxOrderSize - minOrderSize) + minOrderSize,
                        timestamp: Date.now() - Math.random() * 10000,
                        side: 'bid'
                    });
                }

                if (orders.length > 0) {
                    orderbook.bids.push({ price, orders });
                }
            }

            // Create initial ask levels
            for (let i = 0; i < Math.min(maxPriceLevels, 20); i++) {
                const price = parseFloat((midPrice + spreadSize / 2 + i * 0.01).toFixed(3));
                const orders = [];
                const numOrders = Math.max(1, Math.floor(Math.random() * (5 - i * 0.2)));

                for (let j = 0; j < numOrders; j++) {
                    orders.push({
                        id: orderbook.nextOrderId++,
                        price: price,
                        size: Math.random() * (maxOrderSize - minOrderSize) + minOrderSize,
                        timestamp: Date.now() - Math.random() * 10000,
                        side: 'ask'
                    });
                }

                if (orders.length > 0) {
                    orderbook.asks.push({ price, orders });
                }
            }

            orderbook.bids.sort((a, b) => b.price - a.price);
            orderbook.asks.sort((a, b) => a.price - b.price);

            return orderbook;
        }

        function addOrder(orderbook) {
            const balance = calculateBalance(orderbook);

            let sideBias = 0.5;

            if (settings.balanceStrength > 0) {
                const volumeBias = -balance.volumeImbalanceRatio * (settings.balanceStrength / 100);
                const levelBias = -balance.levelImbalanceRatio * (settings.balanceStrength / 100) * 0.3;
                sideBias = 0.5 + volumeBias + levelBias;
                sideBias = Math.max(0.1, Math.min(0.9, sideBias));
            }

            const side = Math.random() < sideBias ? 'bid' : 'ask';
            const levels = side === 'bid' ? orderbook.bids : orderbook.asks;

            if (levels.length === 0) return;

            const bestBid = orderbook.bids.length > 0 ? orderbook.bids[0].price : settings.midPrice - settings.spreadSize;
            const bestAsk = orderbook.asks.length > 0 ? orderbook.asks[0].price : settings.midPrice + settings.spreadSize;

            const levelIndex = Math.floor(Math.random() * Math.min(5, levels.length));
            const targetLevel = levels[levelIndex];

            let price = targetLevel.price;
            if (Math.random() < 0.3) {
                const offset = (Math.random() - 0.5) * settings.spreadSize;
                price = parseFloat((targetLevel.price + offset).toFixed(3));
            }

            if (side === 'bid') {
                price = Math.min(price, bestAsk - settings.minSpread);
            } else {
                price = Math.max(price, bestBid + settings.minSpread);
            }

            if ((side === 'bid' && price >= bestAsk) || (side === 'ask' && price <= bestBid)) {
                return;
            }

            const newOrder = {
                id: orderbook.nextOrderId++,
                price: price,
                size: Math.random() * (settings.maxOrderSize - settings.minOrderSize) + settings.minOrderSize,
                timestamp: Date.now(),
                side: side
            };

            let priceLevel = levels.find(level => Math.abs(level.price - price) < 0.001);
            if (!priceLevel) {
                priceLevel = { price, orders: [] };
                levels.push(priceLevel);
                levels.sort((a, b) => side === 'bid' ? b.price - a.price : a.price - b.price);
            }

            priceLevel.orders.push(newOrder);
        }

        function cancelOrder(orderbook) {
            const allLevels = [...orderbook.bids, ...orderbook.asks];
            const nonEmptyLevels = allLevels.filter(level => level.orders.length > 0);

            if (nonEmptyLevels.length === 0) return;

            const weights = nonEmptyLevels.map((level, index) => 1 / (index + 1));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            const random = Math.random() * totalWeight;

            let cumWeight = 0;
            let selectedLevel;
            for (let i = 0; i < nonEmptyLevels.length; i++) {
                cumWeight += weights[i];
                if (random <= cumWeight) {
                    selectedLevel = nonEmptyLevels[i];
                    break;
                }
            }

            if (selectedLevel && selectedLevel.orders.length > 0) {
                const orderIndex = Math.floor(Math.random() * selectedLevel.orders.length);
                selectedLevel.orders.splice(orderIndex, 1);

                if (selectedLevel.orders.length === 0) {
                    orderbook.bids = orderbook.bids.filter(level => level !== selectedLevel);
                    orderbook.asks = orderbook.asks.filter(level => level !== selectedLevel);
                }
            }
        }

        function fillOrder(orderbook) {
            const topBid = orderbook.bids[0];
            const topAsk = orderbook.asks[0];

            const targets = [topBid, topAsk].filter(level => level && level.orders.length > 0);
            if (targets.length === 0) return;

            const selectedLevel = targets[Math.floor(Math.random() * targets.length)];
            const order = selectedLevel.orders[0];

            const fillSize = Math.random() < 0.7 ? order.size : Math.random() * order.size;
            order.size -= fillSize;

            if (order.size <= 0.01) {
                selectedLevel.orders.shift();
                if (selectedLevel.orders.length === 0) {
                    orderbook.bids = orderbook.bids.filter(level => level !== selectedLevel);
                    orderbook.asks = orderbook.asks.filter(level => level !== selectedLevel);
                }
            }
        }

        function marketSweep(orderbook) {
            const side = Math.random() < 0.5 ? 'buy' : 'sell';
            const targetLevels = side === 'buy' ? orderbook.asks : orderbook.bids;

            if (targetLevels.length === 0) return;

            const levelsToSweep = Math.min(1 + Math.floor(Math.random() * 3), targetLevels.length);
            let remainingSize = Math.random() * 200 + 50;

            for (let i = 0; i < levelsToSweep && remainingSize > 0; i++) {
                const level = targetLevels[0];
                if (!level || level.orders.length === 0) break;

                while (level.orders.length > 0 && remainingSize > 0) {
                    const order = level.orders[0];
                    const consumeSize = Math.min(order.size, remainingSize);

                    order.size -= consumeSize;
                    remainingSize -= consumeSize;

                    if (order.size <= 0.01) {
                        level.orders.shift();
                    }
                }

                if (level.orders.length === 0) {
                    if (side === 'buy') {
                        orderbook.asks = orderbook.asks.filter(l => l !== level);
                    } else {
                        orderbook.bids = orderbook.bids.filter(l => l !== level);
                    }
                }
            }
        }

        function marketMake(orderbook) {
            const balance = calculateBalance(orderbook);
            const bestBid = orderbook.bids.length > 0 ? orderbook.bids[0].price : settings.midPrice - settings.spreadSize;
            const bestAsk = orderbook.asks.length > 0 ? orderbook.asks[0].price : settings.midPrice + settings.spreadSize;

            const currentSpread = bestAsk - bestBid;
            const targetSpread = settings.spreadSize;
            const midPrice = (bestBid + bestAsk) / 2;

            const needsBidLiquidity = balance.volumeImbalanceRatio < -0.1 || balance.levelImbalanceRatio < -0.2;
            const needsAskLiquidity = balance.volumeImbalanceRatio > 0.1 || balance.levelImbalanceRatio > 0.2;

            const addBid = needsBidLiquidity || (!needsAskLiquidity && Math.random() < 0.5);
            const addAsk = needsAskLiquidity || (!needsBidLiquidity && Math.random() < 0.5);

            if (addBid) {
                let bidPrice;
                if (currentSpread > targetSpread * 1.5) {
                    bidPrice = parseFloat((midPrice - targetSpread / 2 + Math.random() * 0.002 - 0.001).toFixed(3));
                } else {
                    bidPrice = parseFloat((bestBid + Math.random() * 0.001).toFixed(3));
                }

                bidPrice = Math.min(bidPrice, bestAsk - settings.minSpread);

                if (bidPrice > 0 && bidPrice < bestAsk) {
                    const bidOrder = {
                        id: orderbook.nextOrderId++,
                        price: bidPrice,
                        size: Math.random() * 30 + 20,
                        timestamp: Date.now(),
                        side: 'bid'
                    };

                    let bidLevel = orderbook.bids.find(level => Math.abs(level.price - bidPrice) < 0.001);
                    if (!bidLevel) {
                        bidLevel = { price: bidPrice, orders: [] };
                        orderbook.bids.push(bidLevel);
                        orderbook.bids.sort((a, b) => b.price - a.price);
                    }
                    bidLevel.orders.push(bidOrder);
                }
            }

            if (addAsk) {
                let askPrice;
                if (currentSpread > targetSpread * 1.5) {
                    askPrice = parseFloat((midPrice + targetSpread / 2 + Math.random() * 0.002 - 0.001).toFixed(3));
                } else {
                    askPrice = parseFloat((bestAsk - Math.random() * 0.001).toFixed(3));
                }

                askPrice = Math.max(askPrice, bestBid + settings.minSpread);

                if (askPrice > bestBid) {
                    const askOrder = {
                        id: orderbook.nextOrderId++,
                        price: askPrice,
                        size: Math.random() * 30 + 20,
                        timestamp: Date.now(),
                        side: 'ask'
                    };

                    let askLevel = orderbook.asks.find(level => Math.abs(level.price - askPrice) < 0.001);
                    if (!askLevel) {
                        askLevel = { price: askPrice, orders: [] };
                        orderbook.asks.push(askLevel);
                        orderbook.asks.sort((a, b) => a.price - b.price);
                    }
                    askLevel.orders.push(askOrder);
                }
            }
        }

        function maintainOrderbook(orderbook) {
            orderbook.bids = orderbook.bids.filter(level => level.orders.length > 0);
            orderbook.asks = orderbook.asks.filter(level => level.orders.length > 0);

            const balance = calculateBalance(orderbook);

            if (orderbook.bids.length > settings.maxPriceLevels) {
                orderbook.bids = orderbook.bids.slice(0, settings.maxPriceLevels);
            }
            if (orderbook.asks.length > settings.maxPriceLevels) {
                orderbook.asks = orderbook.asks.slice(0, settings.maxPriceLevels);
            }

            if (orderbook.bids.length > 0 && orderbook.asks.length > 0) {
                const bestBid = orderbook.bids[0];
                const bestAsk = orderbook.asks[0];

                if (bestBid.price >= bestAsk.price) {
                    if (bestBid.price > bestAsk.price) {
                        if (Math.random() < 0.5) {
                            orderbook.bids.shift();
                        } else {
                            orderbook.asks.shift();
                        }
                    } else if (bestBid.price === bestAsk.price) {
                        if (Math.random() < 0.5) {
                            orderbook.bids.shift();
                        } else {
                            orderbook.asks.shift();
                        }
                    }
                }
            }

            if (settings.balanceStrength > 0) {
                if (Math.abs(balance.volumeImbalanceRatio) > 0.3) {
                    const needsBids = balance.volumeImbalanceRatio < -0.3;
                    const needsAsks = balance.volumeImbalanceRatio > 0.3;

                    if (needsBids && orderbook.bids.length < 5) {
                        const price = orderbook.asks.length > 0 ?
                            parseFloat((orderbook.asks[0].price - settings.spreadSize - Math.random() * 0.01).toFixed(3)) :
                            parseFloat((settings.midPrice - settings.spreadSize).toFixed(3));

                        if (price > 0) {
                            orderbook.bids.push({
                                price,
                                orders: [{
                                    id: orderbook.nextOrderId++,
                                    price,
                                    size: Math.random() * 40 + 20,
                                    timestamp: Date.now(),
                                    side: 'bid'
                                }]
                            });
                            orderbook.bids.sort((a, b) => b.price - a.price);
                        }
                    }

                    if (needsAsks && orderbook.asks.length < 5) {
                        const price = orderbook.bids.length > 0 ?
                            parseFloat((orderbook.bids[0].price + settings.spreadSize + Math.random() * 0.01).toFixed(3)) :
                            parseFloat((settings.midPrice + settings.spreadSize).toFixed(3));

                        orderbook.asks.push({
                            price,
                            orders: [{
                                id: orderbook.nextOrderId++,
                                price,
                                size: Math.random() * 40 + 20,
                                timestamp: Date.now(),
                                side: 'ask'
                            }]
                        });
                        orderbook.asks.sort((a, b) => a.price - b.price);
                    }
                }
            }

            if (Math.random() < 0.05) {
                [orderbook.bids, orderbook.asks].forEach(levels => {
                    if (levels.length > 10) {
                        const farLevel = levels[levels.length - 1];
                        if (farLevel.orders.length > 0 && Math.random() < 0.3) {
                            farLevel.orders.splice(Math.floor(Math.random() * farLevel.orders.length), 1);
                        }
                    }
                });
            }

            if (orderbook.bids.length === 0 || orderbook.asks.length === 0) {
                const midPrice = settings.midPrice;

                if (orderbook.bids.length === 0) {
                    orderbook.bids.push({
                        price: parseFloat((midPrice - settings.spreadSize / 2).toFixed(3)),
                        orders: [{
                            id: orderbook.nextOrderId++,
                            price: parseFloat((midPrice - settings.spreadSize / 2).toFixed(3)),
                            size: Math.random() * 50 + 10,
                            timestamp: Date.now(),
                            side: 'bid'
                        }]
                    });
                }

                if (orderbook.asks.length === 0) {
                    orderbook.asks.push({
                        price: parseFloat((midPrice + settings.spreadSize / 2).toFixed(3)),
                        orders: [{
                            id: orderbook.nextOrderId++,
                            price: parseFloat((midPrice + settings.spreadSize / 2).toFixed(3)),
                            size: Math.random() * 50 + 10,
                            timestamp: Date.now(),
                            side: 'ask'
                        }]
                    });
                }
            }

            if (Math.random() < 0.01 && orderbook.bids.length > 0 && orderbook.asks.length > 0) {
                const imbalance = balance.volumeImbalanceRatio;

                if (Math.abs(imbalance) > 0.2) {
                    const drift = imbalance * 0.001 * (settings.balanceStrength / 100);
                    settings.midPrice = Math.max(50, Math.min(200, settings.midPrice + drift));
                }
            }
        }

        function simulateEvent() {
            if (!orderbook) return;

            const eventTypes = ['ADD_ORDER', 'CANCEL_ORDER', 'FILL_ORDER', 'MARKET_SWEEP', 'MARKET_MAKE'];
            const total = settings.addOrderWeight + settings.cancelOrderWeight + settings.fillOrderWeight + settings.marketSweepWeight + settings.marketMakingWeight;
            const weights = [
                settings.addOrderWeight / total,
                settings.cancelOrderWeight / total,
                settings.fillOrderWeight / total,
                settings.marketSweepWeight / total,
                settings.marketMakingWeight / total
            ];

            const random = Math.random();
            let eventType;
            if (random < weights[0]) eventType = eventTypes[0];
            else if (random < weights[0] + weights[1]) eventType = eventTypes[1];
            else if (random < weights[0] + weights[1] + weights[2]) eventType = eventTypes[2];
            else if (random < weights[0] + weights[1] + weights[2] + weights[3]) eventType = eventTypes[3];
            else eventType = eventTypes[4];

            switch (eventType) {
                case 'ADD_ORDER':
                    addOrder(orderbook);
                    break;
                case 'CANCEL_ORDER':
                    cancelOrder(orderbook);
                    break;
                case 'FILL_ORDER':
                    fillOrder(orderbook);
                    break;
                case 'MARKET_SWEEP':
                    marketSweep(orderbook);
                    break;
                case 'MARKET_MAKE':
                    marketMake(orderbook);
                    break;
            }

            maintainOrderbook(orderbook);

            // Track actual event rate
            const now = Date.now();
            stats.recentEvents = [...stats.recentEvents, now].filter(time => now - time < 5000); // Keep last 5 seconds
            stats.actualRate = stats.recentEvents.length / 5; // Events per second over last 5 seconds
            stats.events++;
            stats.totalOrders = getTotalOrders(orderbook);
            stats.lastRateUpdate = now;

            updateStats();
        }

        function updateVisualization() {
            if (!scene || !orderbook) return;

            textObjects.forEach(obj => {
                scene.remove(obj);
            });
            textObjects = [];

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 2048;

            context.fillStyle = '#000014';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = '16px monospace';

            let y = 50;
            const lineHeight = 25;

            context.fillStyle = '#ffffff';
            context.fillText('L3 ORDERBOOK SIMULATION', 20, y);
            y += lineHeight * 2;

            context.fillText('Price Size Orders', 20, y);
            y += lineHeight;

            const visibleAsks = orderbook.asks.slice(0, 15).reverse();
            visibleAsks.forEach(level => {
                const totalSize = level.orders.reduce((sum, order) => sum + order.size, 0);
                const ordersInfo = level.orders.map(o => o.size.toFixed(1)).join(',');

                context.fillStyle = '#ff6b6b';
                const line = `${level.price.toFixed(3)} ${totalSize.toFixed(1)} [${ordersInfo}]`;
                context.fillText(line, 20, y);
                y += lineHeight;
            });

            y += lineHeight;
            context.fillStyle = '#888888';
            const spread = orderbook.asks[0] && orderbook.bids[0] ?
                (orderbook.asks[0].price - orderbook.bids[0].price).toFixed(3) : 'N/A';
            context.fillText(`--- SPREAD: $${spread} ---`, 20, y);
            y += lineHeight * 2;

            const visibleBids = orderbook.bids.slice(0, 15);
            visibleBids.forEach(level => {
                const totalSize = level.orders.reduce((sum, order) => sum + order.size, 0);
                const ordersInfo = level.orders.map(o => o.size.toFixed(1)).join(',');

                context.fillStyle = '#4ecdc4';
                const line = `${level.price.toFixed(3)} ${totalSize.toFixed(1)} [${ordersInfo}]`;
                context.fillText(line, 20, y);
                y += lineHeight;
            });

            y += lineHeight * 2;
            const balance = calculateBalance(orderbook);
            context.fillStyle = '#ffffff';
            const currentSpread = orderbook.asks[0] && orderbook.bids[0] ?
                (orderbook.asks[0].price - orderbook.bids[0].price).toFixed(3) : 'N/A';
            context.fillText(`Events: ${stats.events} | Target: ${settings.eventsPerSecond}/s | Actual: ${stats.actualRate.toFixed(1)}/s | Spread: ${currentSpread}`, 20, y);
            y += lineHeight;
            context.fillText(`Total Orders: ${stats.totalOrders} | Levels: B${orderbook.bids.length} A${orderbook.asks.length}`, 20, y);
            y += lineHeight;
            context.fillText(`Volume: B${balance.bidVolume.toFixed(1)} A${balance.askVolume.toFixed(1)} | Balance: ${(balance.volumeImbalanceRatio * 100).toFixed(1)}%`, 20, y);
            y += lineHeight;
            context.fillText(`Weights: Add${settings.addOrderWeight}% Cancel${settings.cancelOrderWeight}% Fill${settings.fillOrderWeight}% Sweep${settings.marketSweepWeight}% MM${settings.marketMakingWeight}%`, 20, y);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true
            });

            const geometry = new THREE.PlaneGeometry(10, 20);
            const mesh = new THREE.Mesh(geometry, material);

            scene.add(mesh);
            textObjects.push(mesh);
        }

        function updateStats() {
            document.getElementById('events').textContent = stats.events;
            document.getElementById('totalOrders').textContent = stats.totalOrders;
            document.getElementById('targetRate').textContent = settings.eventsPerSecond;
            document.getElementById('actualRate').textContent = stats.actualRate.toFixed(1);

            if (orderbook) {
                const balance = calculateBalance(orderbook);
                document.getElementById('bidVolume').textContent = balance.bidVolume.toFixed(1);
                document.getElementById('askVolume').textContent = balance.askVolume.toFixed(1);
                document.getElementById('bidLevels').textContent = balance.bidLevels;
                document.getElementById('askLevels').textContent = balance.askLevels;
                document.getElementById('balance').textContent = (balance.volumeImbalanceRatio * 100).toFixed(1);

                // Color code the actual rate and balance based on thresholds
                const actualRateElement = document.getElementById('actualRate');
                if (Math.abs(stats.actualRate - settings.eventsPerSecond) > 2) {
                    actualRateElement.className = 'text-yellow';
                } else {
                    actualRateElement.className = 'text-green';
                }

                const balanceElement = document.getElementById('balance');
                if (Math.abs(balance.volumeImbalanceRatio) > 0.2) {
                    balanceElement.className = 'text-yellow';
                } else {
                    balanceElement.className = 'text-green';
                }
            }
        }

        function scheduleNextEvent() {
            if (isRunning) {
                const interval = generatePoissonInterval();
                simulationTimeout = setTimeout(() => {
                    simulateEvent();
                    scheduleNextEvent();
                }, interval);
            }
        }

        function toggleSimulation() {
            isRunning = !isRunning;

            if (simulationTimeout) {
                clearTimeout(simulationTimeout);
                simulationTimeout = null;
            }

            const toggleBtn = document.getElementById('toggleBtn');
            if (isRunning) {
                toggleBtn.textContent = 'Stop Simulation';
                toggleBtn.className = 'button button-stop';
                scheduleNextEvent();
            } else {
                toggleBtn.textContent = 'Start Simulation';
                toggleBtn.className = 'button button-start';
            }
        }

        function resetSimulation() {
            isRunning = false;

            if (simulationTimeout) {
                clearTimeout(simulationTimeout);
                simulationTimeout = null;
            }

            orderbook = createInitialOrderbook();
            stats = {
                events: 0,
                totalOrders: getTotalOrders(orderbook),
                actualRate: 0,
                lastRateUpdate: Date.now(),
                recentEvents: []
            };

            const toggleBtn = document.getElementById('toggleBtn');
            toggleBtn.textContent = 'Start Simulation';
            toggleBtn.className = 'button button-start';

            updateStats();
        }

        function updateSetting(key, value) {
            settings[key] = parseFloat(value) || 0;

            // Update the display value
            const valueElement = document.getElementById(key + 'Value');
            if (valueElement) {
                if (key === 'spreadSize' || key === 'minSpread') {
                    valueElement.textContent = parseFloat(value).toFixed(3);
                } else if (key === 'midPrice') {
                    valueElement.textContent = parseFloat(value).toFixed(1);
                } else {
                    valueElement.textContent = value;
                }
            }

            // Update target rate display
            if (key === 'eventsPerSecond') {
                document.getElementById('targetRate').textContent = value;
            }
        }

        // Initialize Three.js scene
        function initThreeJS() {
            mount = document.getElementById('visualization');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000014);

            camera = new THREE.PerspectiveCamera(
                75,
                mount.clientWidth / mount.clientHeight,
                0.1,
                1000
            );
            camera.position.set(-2, 0, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(mount.clientWidth, mount.clientHeight);
            mount.appendChild(renderer.domElement);

            orderbook = createInitialOrderbook();
            stats.totalOrders = getTotalOrders(orderbook);
            updateStats();

            function animate() {
                requestAnimationFrame(animate);
                updateVisualization();
                renderer.render(scene, camera);
            }
            animate();

            function handleResize() {
                if (!mount) return;
                const width = mount.clientWidth;
                const height = mount.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
            window.addEventListener('resize', handleResize);
        }

        // Initialize event listeners
        function initEventListeners() {
            document.getElementById('toggleBtn').addEventListener('click', toggleSimulation);
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);

            // Add event listeners for all sliders
            const sliders = [
                'eventsPerSecond', 'midPrice', 'spreadSize', 'minSpread', 'maxPriceLevels',
                'minOrderSize', 'maxOrderSize', 'balanceStrength', 'marketMakingWeight',
                'addOrderWeight', 'cancelOrderWeight', 'fillOrderWeight', 'marketSweepWeight'
            ];

            sliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        updateSetting(sliderId, e.target.value);
                    });
                }
            });
        }

        // Update actual rate calculation periodically
        function startRateUpdateInterval() {
            setInterval(() => {
                if (isRunning) {
                    const now = Date.now();
                    stats.recentEvents = stats.recentEvents.filter(time => now - time < 5000);
                    stats.actualRate = stats.recentEvents.length / 5;
                    updateStats();
                }
            }, 1000); // Update every second
        }

        // Initialize everything when the page loads
        window.addEventListener('load', () => {
            initThreeJS();
            initEventListeners();
            startRateUpdateInterval();
        });
    </script>
</body>

</html>