<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXCHANGE.SIMULATION.SYSTEM</title>
    <style>
        /* Ryoji Ikeda inspired aesthetic - clinical, precise, data-driven */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            line-height: 1.2;
            overflow: hidden;
            user-select: none;
        }

        /* Grid-based layout system */
        .system-container {
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-rows: 60px 3fr 2fr 40px;
            grid-template-areas: 
                "header"
                "main"
                "volume-chart"
                "status";
            overflow: hidden;
        }

        /* Header - clean, technical */
        .system-header {
            grid-area: header;
            background: #000000;
            border-bottom: 1px solid #333333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .system-title {
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .system-controls {
            display: flex;
            gap: 1px;
        }

        /* Ikeda-style buttons */
        .btn {
            background: #000000;
            color: #ffffff;
            border: 1px solid #ffffff;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 80px;
        }

        .btn:hover {
            background: #ffffff;
            color: #000000;
        }

        .btn:active, .btn.active {
            background: #ffffff;
            color: #000000;
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: #000000;
            color: #ffffff;
        }

        /* Main content area - three column grid */
        .main-content {
            grid-area: main;
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            border: 1px solid #333333;
            border-top: none;
            border-bottom: none;
        }

        /* Left panel - controls */
        .controls-panel {
            background: #000000;
            border-right: 1px solid #333333;
            overflow-y: auto;
            font-size: 10px;
        }

        .control-section {
            border-bottom: 1px solid #1a1a1a;
            padding: 15px;
        }

        .control-section h3 {
            font-size: 11px;
            margin-bottom: 10px;
            color: #ffffff;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-section.collapsed .section-content {
            display: none;
        }

        .control-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .toggle-icon {
            transition: transform 0.1s;
            font-size: 8px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            margin-bottom: 3px;
            font-size: 9px;
            color: #cccccc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 6px 8px;
            background: #000000;
            border: 1px solid #666666;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #ffffff;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        /* Center panel - heatmap visualization */
        .heatmap-panel {
            background: #000000;
            border-right: 1px solid #333333;
            position: relative;
            overflow: hidden;
        }

        .heatmap-header {
            background: #000000;
            border-bottom: 1px solid #333333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 40px;
        }

        .heatmap-title {
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .heatmap-info {
            font-size: 9px;
            color: #888888;
        }

        .heatmap-canvas-container {
            position: absolute;
            top: 40px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        #heatmapCanvas {
            display: block;
            background: #000000;
        }

        /* Right panel - orderbook tables */
        .orderbook-panel {
            background: #000000;
            display: flex;
            flex-direction: column;
        }

        .orderbook-header {
            background: #000000;
            border-bottom: 1px solid #333333;
            padding: 10px 15px;
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .orderbook-title {
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .orderbook-stats {
            display: flex;
            gap: 15px;
            font-size: 9px;
            color: #888888;
        }

        .orderbook-content {
            flex: 1;
            display: grid;
            grid-template-rows: 1fr 1fr;
            overflow: hidden;
        }

        .orderbook-side {
            padding: 10px;
            overflow-y: auto;
            border-bottom: 1px solid #333333;
        }

        .orderbook-side:last-child {
            border-bottom: none;
        }

        .orderbook-side h4 {
            font-size: 10px;
            margin-bottom: 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #ffffff;
        }

        .orderbook-level {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 2px 0;
            font-size: 9px;
            font-family: 'Courier New', monospace;
            border-bottom: 1px solid #111111;
        }

        .orderbook-asks .orderbook-level {
            background: linear-gradient(90deg, transparent 0%, rgba(255,0,0,0.1) 100%);
        }

        .orderbook-bids .orderbook-level {
            background: linear-gradient(90deg, transparent 0%, rgba(0,255,0,0.1) 100%);
        }

        .price {
            text-align: right;
            color: #ffffff;
        }

        .quantity {
            text-align: left;
            color: #888888;
            padding-left: 10px;
        }

        /* Status bar */
        .system-status {
            grid-area: status;
            background: #000000;
            border-top: 1px solid #333333;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            align-items: center;
            padding: 0 20px;
            font-size: 9px;
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            color: #ffffff;
            font-weight: bold;
        }

        /* Spread profiles */
        .spread-profile {
            background: #111111;
            border: 1px solid #333333;
            margin-bottom: 8px;
            padding: 10px;
        }

        .spread-profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .profile-title {
            font-size: 9px;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .profile-remove {
            background: #ff0000;
            color: #ffffff;
            border: none;
            width: 16px;
            height: 16px;
            font-size: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .profile-input {
            width: 100%;
            padding: 3px 5px;
            background: #000000;
            border: 1px solid #444444;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 8px;
        }

        /* Loading and error states */
        .loading, .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 12px;
        }

        .loading.hidden, .error.hidden {
            display: none;
        }

        .error {
            color: #ff4444;
            background: #000000;
            border: 1px solid #ff4444;
            padding: 20px;
            max-width: 400px;
        }

        /* Responsive adjustments */
        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 280px 1fr 320px;
            }
        }

        @media (max-width: 1024px) {
            .system-container {
                grid-template-rows: 60px 2fr 1fr 40px;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 300px 1fr;
            }
            
            .controls-panel {
                border-right: none;
                border-bottom: 1px solid #333333;
            }
            
            .heatmap-panel {
                border-right: none;
            }
        }

        @media (max-width: 768px) {
            .system-container {
                grid-template-rows: 60px 5fr 3fr 40px;
            }
            
            .volume-chart-header {
                padding: 8px 12px;
                height: 35px;
            }
            
            .volume-chart-title, .volume-chart-info {
                font-size: 10px;
            }
        }

        /* Data visualization specific styles */
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 1px;
            background: #333333;
        }

        .data-cell {
            background: #000000;
            padding: 4px;
            text-align: center;
            font-size: 8px;
            border: 1px solid #333333;
        }

        /* Precision indicators */
        .precision-indicator {
            width: 2px;
            height: 2px;
            background: #ffffff;
            display: inline-block;
            margin: 0 1px;
        }

        /* Technical readouts */
        .readout {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            color: #00ff00;
            background: #000000;
            padding: 2px 4px;
            border: 1px solid #004400;
        }

        /* Volume barplot panel */
        .volume-chart-panel {
            grid-area: volume-chart;
            background: #000000;
            border-top: 1px solid #333333;
            border-bottom: 1px solid #333333;
            display: flex;
            flex-direction: column;
        }

        .volume-chart-header {
            background: #000000;
            border-bottom: 1px solid #333333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 40px;
        }

        .volume-chart-title {
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .volume-chart-info {
            display: flex;
            gap: 15px;
            font-size: 9px;
            color: #888888;
        }

        .volume-chart-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #volumeChartCanvas {
            display: block;
            background: #000000;
        }
    </style>
</head>
<body>
    <div class="system-container">
        <!-- System Header -->
        <div class="system-header">
            <div class="system-title">EXCHANGE.SIMULATION.SYSTEM</div>
            <div class="system-controls">
                <button id="initBtn" class="btn">INIT</button>
                <button id="startBtn" class="btn" disabled>START</button>
                <button id="stopBtn" class="btn" disabled>STOP</button>
                <button id="resetBtn" class="btn">RESET</button>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="main-content">
            <!-- Left Panel: Controls -->
            <div class="controls-panel">
                <!-- Basic Parameters -->
                <div class="control-section">
                    <h3 onclick="toggleSection(this)">BASIC.PARAMS <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>AGENTS</label>
                            <input type="number" id="agents" min="1" max="1000" value="10">
                        </div>
                        <div class="form-group">
                            <label>SYMBOL</label>
                            <input type="text" id="symbol" value="BTC/USD">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>SEED</label>
                                <input type="number" id="seed" value="47">
                            </div>
                            <div class="form-group">
                                <label>SPEED</label>
                                <input type="number" id="speedFactor" min="1" max="1000" value="100">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Spread Profiles -->
                <div class="control-section">
                    <h3 onclick="toggleSection(this)">SPREAD.PROFILES <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div style="margin-bottom: 10px; display: flex; gap: 2px;">
                            <button onclick="addPresetProfile('tight')" class="btn" style="font-size: 8px; padding: 4px 8px;">TIGHT</button>
                            <button onclick="addPresetProfile('wide')" class="btn" style="font-size: 8px; padding: 4px 8px;">WIDE</button>
                            <button onclick="addPresetProfile('mixed')" class="btn" style="font-size: 8px; padding: 4px 8px;">MIXED</button>
                        </div>
                        <div id="spreadProfiles"></div>
                        <button id="addSpreadProfile" class="btn" style="font-size: 8px; padding: 4px 8px; width: 100%;">+ ADD</button>
                    </div>
                </div>

                <!-- Order Timeouts -->
                <div class="control-section collapsed">
                    <h3 onclick="toggleSection(this)">ORDER.TIMEOUTS <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>DISTRIBUTION</label>
                            <select id="timeoutDist">
                                <option value="lognormal">LOG-NORMAL</option>
                                <option value="pareto">PARETO</option>
                                <option value="lognormal_pareto_mix">MIXED</option>
                            </select>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>MEDIAN (S)</label>
                                <input type="number" id="medianTimeout" min="0.1" max="60" value="5" step="0.1">
                            </div>
                            <div class="form-group">
                                <label>SIGMA</label>
                                <input type="number" id="sigmaTimeout" min="0.1" max="5" value="0.8" step="0.1">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>P.ALPHA</label>
                                <input type="number" id="paretoAlpha" min="0.1" max="5" value="1.5" step="0.1">
                            </div>
                            <div class="form-group">
                                <label>P.SCALE</label>
                                <input type="number" id="paretoScale" min="1" max="100" value="5" step="1">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>TAIL.MIX</label>
                                <input type="number" id="tailMix" min="0" max="1" value="0.1" step="0.05">
                            </div>
                            <div class="form-group">
                                <label>MIN.T (S)</label>
                                <input type="number" id="minTimeoutS" min="0.1" max="60" value="1" step="0.1">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>MAX.T (S)</label>
                            <input type="number" id="maxTimeoutS" min="1" max="3600" value="60" step="1">
                        </div>
                    </div>
                </div>

                <!-- Order Sizes -->
                <div class="control-section collapsed">
                    <h3 onclick="toggleSection(this)">ORDER.SIZES <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-row">
                            <div class="form-group">
                                <label>MIN.RANGE</label>
                                <input type="number" id="minSizeMin" min="0.001" max="1" value="0.01" step="0.001">
                            </div>
                            <div class="form-group">
                                <label></label>
                                <input type="number" id="minSizeMax" min="0.001" max="1" value="0.1" step="0.001">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>MAX.RANGE</label>
                                <input type="number" id="maxSizeMin" min="0.001" max="10" value="0.1" step="0.001">
                            </div>
                            <div class="form-group">
                                <label></label>
                                <input type="number" id="maxSizeMax" min="0.001" max="10" value="0.5" step="0.001">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Imbalance Parameters -->
                <div class="control-section collapsed">
                    <h3 onclick="toggleSection(this)">IMBALANCE.PARAMS <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-row">
                            <div class="form-group">
                                <label>LEVELS</label>
                                <input type="number" id="imbalanceLevelsMin" min="1" max="10" value="1" step="1">
                            </div>
                            <div class="form-group">
                                <label></label>
                                <input type="number" id="imbalanceLevelsMax" min="1" max="10" value="3" step="1">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>ADJ.BPS</label>
                                <input type="number" id="maxImbalanceAdjMin" min="0" max="100" value="2" step="1">
                            </div>
                            <div class="form-group">
                                <label></label>
                                <input type="number" id="maxImbalanceAdjMax" min="0" max="100" value="10" step="1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Advanced Settings -->
                <div class="control-section collapsed">
                    <h3 onclick="toggleSection(this)">ADVANCED <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-row">
                            <div class="form-group">
                                <label>WARMUP (MS)</label>
                                <input type="number" id="warmupMin" min="0" max="5000" value="0" step="10">
                            </div>
                            <div class="form-group">
                                <label></label>
                                <input type="number" id="warmupMax" min="0" max="5000" value="0" step="10">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>SEED.LEVELS</label>
                            <input type="number" id="seedLevels" min="1" max="20" value="5" step="1">
                        </div>
                    </div>
                </div>

                <!-- Heatmap Config -->
                <div class="control-section collapsed">
                    <h3 onclick="toggleSection(this)">HEATMAP.CONFIG <span class="toggle-icon">▼</span></h3>
                    <div class="section-content">
                        <div class="form-group">
                            <label>BUFFER.SIZE</label>
                            <input type="number" id="heatmapBufferSize" min="50" max="1000" value="300">
                        </div>
                        <div class="form-group">
                            <label>UPDATE.FREQ</label>
                            <input type="number" id="heatmapUpdateFreq" min="1" max="50" value="5">
                        </div>
                        <div class="form-group">
                            <label>INTENSITY</label>
                            <input type="range" id="heatmapIntensity" min="1" max="10" value="3">
                        </div>
                        <div class="form-group">
                            <label style="display: flex; align-items: center;">
                                <input type="checkbox" id="heatmapEnabled" checked style="margin-right: 8px;">
                                ENABLED
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Panel: Heatmap -->
            <div class="heatmap-panel">
                <div class="heatmap-header">
                    <div class="heatmap-title">DEPTH.HEATMAP</div>
                    <div class="heatmap-info">
                        <span>BUFFER: <span id="heatmapBufferUsage">0</span>/<span id="heatmapBufferMax">300</span></span>
                        <span style="margin-left: 10px;">UPDATES: <span id="heatmapUpdateCount">0</span></span>
                    </div>
                </div>
                <div class="heatmap-canvas-container">
                    <canvas id="heatmapCanvas"></canvas>
                    <div id="heatmapLoading" class="loading">
                        <div>INITIALIZING HEATMAP</div>
                        <div style="font-size: 10px; margin-top: 10px; color: #888;">WAITING FOR DATA</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Orderbook -->
            <div class="orderbook-panel">
                <div class="orderbook-header">
                    <div class="orderbook-title">L2.ORDERBOOK</div>
                    <div class="orderbook-stats">
                        <span>SYMBOL: <span id="currentSymbol">-</span></span>
                        <span>UPDATES: <span id="l2UpdateCount">0</span></span>
                    </div>
                </div>
                <div class="orderbook-content">
                    <div class="orderbook-side orderbook-asks">
                        <h4>ASKS</h4>
                        <div id="askLevels"></div>
                    </div>
                    <div class="orderbook-side orderbook-bids">
                        <h4>BIDS</h4>
                        <div id="bidLevels"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Volume Barplot Panel -->
        <div class="volume-chart-panel">
            <div class="volume-chart-header">
                <div class="volume-chart-title">VOLUME.DISTRIBUTION</div>
                <div class="volume-chart-info">
                    <span>LEVELS: <span id="volumeChartLevels">0</span></span>
                    <span>MAX.VOL: <span id="volumeChartMaxVol">0.000</span></span>
                    <span>MID: <span id="volumeChartMidPrice">0.00</span></span>
                </div>
            </div>
            <div class="volume-chart-canvas-container">
                <canvas id="volumeChartCanvas"></canvas>
                <div id="volumeChartLoading" class="loading">
                    <div>WAITING FOR VOLUME DATA</div>
                    <div style="font-size: 10px; margin-top: 10px; color: #888;">INITIALIZE SIMULATION</div>
                </div>
            </div>
        </div>

        <!-- System Status Bar -->
        <div class="system-status">
            <div class="status-item">
                <div class="status-label">STATUS</div>
                <div class="status-value" id="simStatus">IDLE</div>
            </div>
            <div class="status-item">
                <div class="status-label">QUEUE</div>
                <div class="status-value" id="queueSize">0</div>
            </div>
            <div class="status-item">
                <div class="status-label">L2.COUNT</div>
                <div class="status-value" id="updateCount">0</div>
            </div>
            <div class="status-item">
                <div class="status-label">MID.PRICE</div>
                <div class="status-value" id="midPrice">0.00</div>
            </div>
            <div class="status-item">
                <div class="status-label">SPREAD</div>
                <div class="status-value" id="spread">0.00</div>
            </div>
            <div class="status-item">
                <div class="status-label">AGENTS</div>
                <div class="status-value" id="activeAgents">0</div>
            </div>
        </div>

        <!-- Error Display -->
        <div id="error" class="error hidden">
            <div>SYSTEM ERROR</div>
            <div id="errorMessage" style="font-size: 10px; margin-top: 10px;"></div>
        </div>
    </div>

    <script>
        // Optimized Orderbook Heatmap Visualization
        class OrderbookHeatmap {
            constructor() {
                this.canvas = document.getElementById('heatmapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // State
                this.isPlaying = false;
                this.updateCount = 0;
                this.lastMidPrice = 50000;
                this.lastSpread = 5;
                this.heatmapData = null;
                this.usingSyntheticData = false;
                
                // Configuration
                this.config = {
                    bufferSize: 300,
                    priceLevels: 200,
                    tickSize: 1.0,
                    updateFreq: 5,
                    intensity: 3
                };
                
                // Visual parameters
                this.cellWidth = 3;
                this.cellHeight = 2;
                this.leftMargin = 60;
                this.topMargin = 30;
                
                // Performance optimizations - preallocated buffers
                this.maxBufferSize = 300;
                this.dataBuffer = new Array(this.maxBufferSize);
                this.bufferHead = 0;
                this.bufferSize = 0;
                
                // Preallocated arrays for synthetic data
                this.preallocatedBids = new Array(this.config.priceLevels);
                this.preallocatedAsks = new Array(this.config.priceLevels);
                this.preallocatedPrices = new Array(this.config.priceLevels);
                
                // Color cache for performance
                this.colorCache = new Map();
                this.precomputeColors();
                
                // Offscreen canvas for double buffering
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                
                // Reusable ImageData for efficient pixel manipulation
                this.imageData = null;
                this.pixels = null;
                
                this.syntheticInterval = null;
                
                this.setupCanvas();
                this.setupEventListeners();
            }
            
            precomputeColors() {
                // Precompute color values to avoid runtime calculations
                this.bidColors = [];
                this.askColors = [];
                
                for (let i = 0; i <= 100; i++) {
                    const intensity = i / 100;
                    const adjustedIntensity = Math.pow(intensity, 1 / this.config.intensity) * this.config.intensity;
                    
                    let color;
                    if (adjustedIntensity < 0.1) color = '#000000';
                    else if (adjustedIntensity < 0.3) color = '#222222';
                    else if (adjustedIntensity < 0.5) color = '#444444';
                    else if (adjustedIntensity < 0.7) color = '#777777';
                    else if (adjustedIntensity < 0.9) color = '#aaaaaa';
                    else color = '#ffffff';
                    
                    this.bidColors[i] = color;
                    this.askColors[i] = color;
                }
            }
            
            setupCanvas() {
                this.handleResize();
                this.clearCanvas();
            }
            
            setupEventListeners() {
                // Throttled resize handler
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.handleResize(), 100);
                });
                
                const intensitySlider = document.getElementById('heatmapIntensity');
                if (intensitySlider) {
                    intensitySlider.addEventListener('input', (e) => {
                        this.config.intensity = parseInt(e.target.value);
                        this.precomputeColors(); // Recompute colors when intensity changes
                    });
                }
                
                const bufferSizeInput = document.getElementById('heatmapBufferSize');
                if (bufferSizeInput) {
                    bufferSizeInput.addEventListener('change', (e) => {
                        const newSize = parseInt(e.target.value);
                        this.resizeBuffer(newSize);
                        document.getElementById('heatmapBufferMax').textContent = newSize;
                    });
                }
                
                const updateFreqInput = document.getElementById('heatmapUpdateFreq');
                if (updateFreqInput) {
                    updateFreqInput.addEventListener('change', (e) => {
                        this.config.updateFreq = parseInt(e.target.value);
                    });
                }
            }
            
            resizeBuffer(newSize) {
                if (newSize === this.maxBufferSize) return;
                
                const oldBuffer = this.dataBuffer;
                const oldSize = this.bufferSize;
                const oldHead = this.bufferHead;
                
                this.maxBufferSize = newSize;
                this.dataBuffer = new Array(newSize);
                
                // Copy existing data efficiently
                const copySize = Math.min(oldSize, newSize);
                for (let i = 0; i < copySize; i++) {
                    const oldIndex = (oldHead - copySize + i + oldBuffer.length) % oldBuffer.length;
                    this.dataBuffer[i] = oldBuffer[oldIndex];
                }
                
                this.bufferHead = copySize % newSize;
                this.bufferSize = copySize;
                this.config.bufferSize = newSize;
            }
            
            startVisualization(useRealData = true) {
                console.log('[Heatmap] Starting visualization, useRealData:', useRealData);
                this.isPlaying = true;
                
                if (!useRealData && !this.syntheticInterval) {
                    console.log('[Heatmap] Starting synthetic data generation');
                    this.usingSyntheticData = true;
                    this.startSyntheticData();
                } else if (useRealData && this.syntheticInterval) {
                    console.log('[Heatmap] Stopping synthetic data, switching to real data');
                    this.stopSyntheticData();
                    this.usingSyntheticData = false;
                }
                
                const loading = document.getElementById('heatmapLoading');
                if (loading && !loading.classList.contains('hidden')) {
                    loading.classList.add('hidden');
                }
            }
            
            stopVisualization() {
                console.log('[Heatmap] Stopping visualization');
                this.isPlaying = false;
                this.stopSyntheticData();
                this.usingSyntheticData = false;
            }
            
            startSyntheticData() {
                if (this.syntheticInterval) return;
                
                console.log('[Heatmap] Starting synthetic data generation');
                
                let counter = 0;
                this.syntheticInterval = setInterval(() => {
                    if (!this.isPlaying || !this.usingSyntheticData) return;
                    
                    if (counter % this.config.updateFreq === 0) {
                        const heatmapData = this.generateSyntheticHeatmapData();
                        this.onHeatmapUpdate(heatmapData);
                    }
                    
                    counter++;
                }, 200);
            }
            
            stopSyntheticData() {
                if (this.syntheticInterval) {
                    console.log('[Heatmap] Stopping synthetic data generation');
                    clearInterval(this.syntheticInterval);
                    this.syntheticInterval = null;
                }
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                const newWidth = Math.max(400, rect.width - 20);
                const newHeight = Math.max(300, rect.height - 20);
                
                // Only resize if dimensions actually changed
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                    
                    // Resize offscreen canvas
                    this.offscreenCanvas.width = newWidth;
                    this.offscreenCanvas.height = newHeight;
                    
                    // Recreate ImageData
                    this.imageData = this.ctx.createImageData(newWidth, newHeight);
                    this.pixels = this.imageData.data;
                    
                    // Recalculate cell dimensions
                    const availableWidth = newWidth - this.leftMargin - 20;
                    const availableHeight = newHeight - this.topMargin - 20;
                    
                    this.cellWidth = Math.max(2, Math.floor(availableWidth / this.config.bufferSize));
                    this.cellHeight = Math.max(1, Math.floor(availableHeight / this.config.priceLevels));
                    
                    this.redraw();
                }
            }
            
            clearCanvas() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            onL2Update(event) {
                if (!this.isPlaying) return;
                
                if (event.bids && event.bids.length > 0 && event.asks && event.asks.length > 0) {
                    this.lastMidPrice = (event.bids[0].price + event.asks[0].price) / 2;
                    this.lastSpread = event.asks[0].price - event.bids[0].price;
                }
                
                if (this.usingSyntheticData) {
                    console.log('[Heatmap] Received real L2 data, stopping synthetic generation');
                    this.stopSyntheticData();
                    this.usingSyntheticData = false;
                }
            }
            
            onHeatmapUpdate(heatmapData) {
                if (!this.isPlaying) return;
                
                this.updateCount++;
                document.getElementById('heatmapUpdateCount').textContent = this.updateCount;
                
                this.addToDataBuffer(heatmapData);
                document.getElementById('heatmapBufferUsage').textContent = this.bufferSize;
                
                // Use requestAnimationFrame for smooth rendering
                if (!this.renderPending) {
                    this.renderPending = true;
                    requestAnimationFrame(() => {
                        this.renderTimeSeriesHeatmap();
                        this.renderPending = false;
                    });
                }
            }
            
            addToDataBuffer(heatmapData) {
                // Efficient circular buffer implementation
                const entry = this.dataBuffer[this.bufferHead] || {};
                
                // Reuse existing arrays if they exist
                if (!entry.bidVolumes || entry.bidVolumes.length !== heatmapData.bidVolumes.length) {
                    entry.bidVolumes = new Array(heatmapData.bidVolumes.length);
                }
                if (!entry.askVolumes || entry.askVolumes.length !== heatmapData.askVolumes.length) {
                    entry.askVolumes = new Array(heatmapData.askVolumes.length);
                }
                
                // Copy data without creating new arrays
                for (let i = 0; i < heatmapData.bidVolumes.length; i++) {
                    entry.bidVolumes[i] = heatmapData.bidVolumes[i];
                }
                for (let i = 0; i < heatmapData.askVolumes.length; i++) {
                    entry.askVolumes[i] = heatmapData.askVolumes[i];
                }
                
                entry.midPrice = heatmapData.midPrice;
                entry.timestamp = heatmapData.timestamp || Date.now();
                entry.stats = heatmapData.stats;
                
                this.dataBuffer[this.bufferHead] = entry;
                this.bufferHead = (this.bufferHead + 1) % this.maxBufferSize;
                
                if (this.bufferSize < this.maxBufferSize) {
                    this.bufferSize++;
                }
                
                this.heatmapData = heatmapData;
            }
            
            renderTimeSeriesHeatmap() {
                // Use offscreen canvas for double buffering
                const ctx = this.offscreenCtx;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
                
                if (this.bufferSize === 0) {
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
                    return;
                }
                
                const availableWidth = this.offscreenCanvas.width - this.leftMargin - 20;
                const maxCols = Math.floor(availableWidth / this.cellWidth);
                
                const numTimePoints = Math.min(this.bufferSize, maxCols);
                const { maxVolume } = this.calculateGlobalVolumeStats(numTimePoints);
                
                if (maxVolume === 0) {
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
                    return;
                }
                
                // Batch render all columns
                for (let timeIndex = 0; timeIndex < numTimePoints; timeIndex++) {
                    const dataIndex = (this.bufferHead - numTimePoints + timeIndex + this.maxBufferSize) % this.maxBufferSize;
                    const data = this.dataBuffer[dataIndex];
                    
                    if (!data) continue;
                    
                    const x = this.leftMargin + timeIndex * this.cellWidth;
                    this.renderColumnOptimized(ctx, x, data, maxVolume);
                }
                
                // Draw overlays on offscreen canvas
                if (this.heatmapData) {
                    this.drawPriceLabels(ctx, this.heatmapData);
                    this.drawMidPriceLine(ctx, this.heatmapData);
                    this.drawTimeAxis(ctx, numTimePoints);
                }
                
                // Copy offscreen canvas to main canvas in one operation
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }
            
            renderColumnOptimized(ctx, x, data, maxVolume) {
                const { bidVolumes, askVolumes } = data;
                const numLevels = Math.min(bidVolumes.length, askVolumes.length);
                
                // Batch fill operations by color
                const bidOperations = new Map();
                const askOperations = new Map();
                
                for (let level = 0; level < numLevels; level++) {
                    const y = this.topMargin + level * this.cellHeight;
                    
                    // Group bid operations by color
                    if (level < bidVolumes.length && bidVolumes[level] > 0) {
                        const intensity = Math.min(100, Math.floor((bidVolumes[level] / maxVolume) * 100));
                        const color = this.bidColors[intensity];
                        
                        if (!bidOperations.has(color)) {
                            bidOperations.set(color, []);
                        }
                        bidOperations.get(color).push({ x, y, width: this.cellWidth / 2, height: this.cellHeight });
                    }
                    
                    // Group ask operations by color
                    if (level < askVolumes.length && askVolumes[level] > 0) {
                        const intensity = Math.min(100, Math.floor((askVolumes[level] / maxVolume) * 100));
                        const color = this.askColors[intensity];
                        
                        if (!askOperations.has(color)) {
                            askOperations.set(color, []);
                        }
                        askOperations.get(color).push({ x: x + this.cellWidth / 2, y, width: this.cellWidth / 2, height: this.cellHeight });
                    }
                }
                
                // Execute batched operations
                for (const [color, operations] of bidOperations) {
                    ctx.fillStyle = color;
                    for (const op of operations) {
                        ctx.fillRect(op.x, op.y, op.width, op.height);
                    }
                }
                
                for (const [color, operations] of askOperations) {
                    ctx.fillStyle = color;
                    for (const op of operations) {
                        ctx.fillRect(op.x, op.y, op.width, op.height);
                    }
                }
            }
            
            calculateGlobalVolumeStats(numTimePoints) {
                const volumeSamples = [];
                
                for (let i = 0; i < numTimePoints; i++) {
                    const dataIndex = (this.bufferHead - numTimePoints + i + this.maxBufferSize) % this.maxBufferSize;
                    const data = this.dataBuffer[dataIndex];
                    
                    if (!data) continue;
                    
                    // Sample every nth volume to reduce computation
                    const step = Math.max(1, Math.floor(data.bidVolumes.length / 50));
                    for (let j = 0; j < data.bidVolumes.length; j += step) {
                        if (data.bidVolumes[j] > 0) volumeSamples.push(data.bidVolumes[j]);
                        if (data.askVolumes[j] > 0) volumeSamples.push(data.askVolumes[j]);
                    }
                }
                
                if (volumeSamples.length === 0) return { maxVolume: 0 };
                
                // Use 95th percentile for better visual scaling
                volumeSamples.sort((a, b) => a - b);
                const p95Volume = volumeSamples[Math.floor(volumeSamples.length * 0.95)];
                
                return { maxVolume: p95Volume };
            }
            
            drawPriceLabels(ctx, data) {
                if (!data.priceLabels || !data.midPrice) return;
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '8px Courier New';
                ctx.textAlign = 'right';
                
                const midLevel = Math.floor(data.numLevels / 2);
                const labelStep = Math.max(1, Math.floor(data.numLevels / 15));
                
                for (let level = 0; level < data.numLevels; level += labelStep) {
                    if (level < data.priceLabels.length) {
                        const price = data.priceLabels[level];
                        const y = this.topMargin + level * this.cellHeight + this.cellHeight / 2;
                        
                        ctx.fillStyle = Math.abs(level - midLevel) < 3 ? '#00ff00' : '#888888';
                        ctx.fillText(price.toFixed(1), this.leftMargin - 5, y + 2);
                    }
                }
            }
            
            drawMidPriceLine(ctx, data) {
                if (!data.midPrice || !data.numLevels) return;
                
                const midLevel = Math.floor(data.numLevels / 2);
                const y = this.topMargin + midLevel * this.cellHeight + this.cellHeight / 2;
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                
                ctx.beginPath();
                ctx.moveTo(this.leftMargin, y);
                ctx.lineTo(this.offscreenCanvas.width - 20, y);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            drawTimeAxis(ctx, numTimePoints) {
                const step = Math.max(1, Math.floor(numTimePoints / 8));
                
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                ctx.font = '7px Courier New';
                ctx.fillStyle = '#666666';
                ctx.textAlign = 'center';
                
                for (let i = 0; i < numTimePoints; i += step) {
                    const x = this.leftMargin + i * this.cellWidth + this.cellWidth / 2;
                    const y1 = this.topMargin - 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y1 + 3);
                    ctx.stroke();
                    
                    const timeLabel = `T-${numTimePoints - i - 1}`;
                    ctx.fillText(timeLabel, x, y1 - 2);
                }
                
                if (numTimePoints > 0) {
                    const x = this.leftMargin + (numTimePoints - 1) * this.cellWidth + this.cellWidth / 2;
                    const y1 = this.topMargin - 10;
                    const y2 = this.topMargin + this.config.priceLevels * this.cellHeight + 10;
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText('NOW', x, y1 - 2);
                }
            }
            
            generateSyntheticHeatmapData() {
                const numLevels = this.config.priceLevels;
                
                // Reuse preallocated arrays
                const bidVolumes = this.preallocatedBids;
                const askVolumes = this.preallocatedAsks;
                const priceLabels = this.preallocatedPrices;
                
                const basePrice = 50000 + (Math.sin(Date.now() * 0.0001) * 500);
                const midLevel = Math.floor(numLevels / 2);
                
                const timePhase = Date.now() * 0.001;
                const marketCycle = Math.sin(timePhase * 0.1);
                const volatilityPhase = Math.sin(timePhase * 0.3);
                
                for (let level = 0; level < numLevels; level++) {
                    const distanceFromMid = Math.abs(level - midLevel);
                    const normDistance = distanceFromMid / (numLevels / 2);
                    
                    const baseVolume = Math.exp(-distanceFromMid * 0.1) * 15;
                    const cyclePattern = 1 + 0.5 * Math.sin(timePhase + level * 0.1);
                    const volatilityBoost = 1 + 0.3 * Math.abs(volatilityPhase) * Math.exp(-normDistance * 2);
                    const randomNoise = 0.7 + 0.6 * Math.random();
                    
                    const imbalance = marketCycle * 0.3;
                    const bidBoost = level < midLevel ? (1 + Math.max(0, imbalance)) : (1 + Math.max(0, -imbalance));
                    const askBoost = level > midLevel ? (1 + Math.max(0, -imbalance)) : (1 + Math.max(0, imbalance));
                    
                    bidVolumes[level] = level <= midLevel ? 
                        baseVolume * cyclePattern * volatilityBoost * bidBoost * randomNoise : 0;
                    askVolumes[level] = level >= midLevel ? 
                        baseVolume * cyclePattern * volatilityBoost * askBoost * randomNoise : 0;
                    
                    if (level === midLevel) {
                        bidVolumes[level] *= 0.3;
                        askVolumes[level] *= 0.3;
                    }
                    
                    priceLabels[level] = basePrice + (level - midLevel) * this.config.tickSize;
                }
                
                // Random volume spikes
                if (Math.random() < 0.1) {
                    const spikeLevel = Math.floor(Math.random() * numLevels);
                    const spikeIntensity = 3 + Math.random() * 7;
                    
                    if (bidVolumes[spikeLevel] > 0) bidVolumes[spikeLevel] *= spikeIntensity;
                    if (askVolumes[spikeLevel] > 0) askVolumes[spikeLevel] *= spikeIntensity;
                }
                
                return {
                    bidVolumes, askVolumes, priceLabels,
                    midPrice: basePrice, basePrice, 
                    tickSize: this.config.tickSize,
                    numLevels, timestamp: Date.now()
                };
            }
            
            redraw() {
                if (this.bufferSize > 0) {
                    this.renderTimeSeriesHeatmap();
                } else {
                    this.clearCanvas();
                }
            }
            
            cleanup() {
                this.stopVisualization();
                
                // Clear caches
                this.colorCache.clear();
                this.bidColors = null;
                this.askColors = null;
                
                // Clear buffers
                this.dataBuffer = null;
                this.preallocatedBids = null;
                this.preallocatedAsks = null;
                this.preallocatedPrices = null;
                
                // Clean up canvases
                this.offscreenCanvas = null;
                this.offscreenCtx = null;
                this.imageData = null;
                this.pixels = null;
            }
        }

        // Volume Distribution Barplot Visualization
        class VolumeBarplot {
            constructor() {
                this.canvas = document.getElementById('volumeChartCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // State
                this.isPlaying = false;
                this.currentData = null;
                this.lastMidPrice = 50000;
                
                // Visual parameters
                this.leftMargin = 60;
                this.rightMargin = 20;
                this.topMargin = 30;
                this.bottomMargin = 40;
                
                // Chart configuration
                this.config = {
                    maxBars: 100,
                    barSpacing: 1,
                    bidColor: '#00ff4411',
                    askColor: '#ff004411',
                    bidColorIntense: '#00ff44',
                    askColorIntense: '#ff0044',
                    textColor: '#ffffff',
                    gridColor: '#333333'
                };
                
                // Performance optimizations
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                
                this.setupCanvas();
                this.setupEventListeners();
            }
            
            setupCanvas() {
                this.handleResize();
                this.clearCanvas();
            }
            
            setupEventListeners() {
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.handleResize(), 100);
                });
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                const newWidth = Math.max(400, rect.width - 20);
                const newHeight = Math.max(150, rect.height - 20);
                
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                    
                    this.offscreenCanvas.width = newWidth;
                    this.offscreenCanvas.height = newHeight;
                    
                    this.redraw();
                }
            }
            
            clearCanvas() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            startVisualization() {
                this.isPlaying = true;
                const loading = document.getElementById('volumeChartLoading');
                if (loading && !loading.classList.contains('hidden')) {
                    loading.classList.add('hidden');
                }
            }
            
            stopVisualization() {
                this.isPlaying = false;
                this.currentData = null;
                this.clearCanvas();
                
                const loading = document.getElementById('volumeChartLoading');
                if (loading && loading.classList.contains('hidden')) {
                    loading.classList.remove('hidden');
                }
            }
            
            onVolumeUpdate(heatmapData) {
                if (!this.isPlaying || !heatmapData) return;
                
                this.currentData = heatmapData;
                this.lastMidPrice = heatmapData.midPrice || this.lastMidPrice;
                
                // Update info display
                this.updateInfoDisplay(heatmapData);
                
                // Render with requestAnimationFrame for smooth updates
                if (!this.renderPending) {
                    this.renderPending = true;
                    requestAnimationFrame(() => {
                        this.renderVolumeChart();
                        this.renderPending = false;
                    });
                }
            }
            
            updateInfoDisplay(data) {
                const levelsElement = document.getElementById('volumeChartLevels');
                const maxVolElement = document.getElementById('volumeChartMaxVol');
                const midPriceElement = document.getElementById('volumeChartMidPrice');
                
                if (levelsElement) {
                    levelsElement.textContent = Math.min(data.bidVolumes.length, data.askVolumes.length);
                }
                
                if (maxVolElement && data.bidVolumes && data.askVolumes) {
                    const maxVol = Math.max(
                        Math.max(...data.bidVolumes.filter(v => v > 0)),
                        Math.max(...data.askVolumes.filter(v => v > 0))
                    );
                    maxVolElement.textContent = formatQuantity(maxVol);
                }
                
                if (midPriceElement && data.midPrice) {
                    midPriceElement.textContent = formatPrice(data.midPrice);
                }
            }
            
            renderVolumeChart() {
                if (!this.currentData) {
                    this.clearCanvas();
                    return;
                }
                
                // Use offscreen canvas for double buffering
                const ctx = this.offscreenCtx;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
                
                const data = this.currentData;
                const { bidVolumes, askVolumes, priceLabels, midPrice } = data;
                
                if (!bidVolumes || !askVolumes || bidVolumes.length === 0) {
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
                    return;
                }
                
                // Calculate chart dimensions
                const chartWidth = this.offscreenCanvas.width - this.leftMargin - this.rightMargin;
                const chartHeight = this.offscreenCanvas.height - this.topMargin - this.bottomMargin;
                
                // Determine price range and bar width
                const numLevels = Math.min(bidVolumes.length, askVolumes.length);
                const visibleLevels = Math.min(numLevels, this.config.maxBars);
                const barWidth = Math.max(1, (chartWidth - (visibleLevels - 1) * this.config.barSpacing) / visibleLevels);
                
                // Find mid level and calculate visible range
                const midLevel = Math.floor(numLevels / 2);
                const halfVisible = Math.floor(visibleLevels / 2);
                const startLevel = Math.max(0, midLevel - halfVisible);
                const endLevel = Math.min(numLevels, startLevel + visibleLevels);
                
                // Calculate max volume for scaling
                let maxVolume = 0;
                for (let i = startLevel; i < endLevel; i++) {
                    maxVolume = Math.max(maxVolume, bidVolumes[i] || 0, askVolumes[i] || 0);
                }
                
                if (maxVolume === 0) {
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
                    return;
                }
                
                // Draw grid lines
                this.drawGrid(ctx, chartWidth, chartHeight, maxVolume);
                
                // Draw volume bars
                for (let i = startLevel; i < endLevel; i++) {
                    const barIndex = i - startLevel;
                    const x = this.leftMargin + barIndex * (barWidth + this.config.barSpacing);
                    
                    // Draw bid volume (bottom half or full if no ask)
                    const bidVol = bidVolumes[i] || 0;
                    const askVol = askVolumes[i] || 0;
                    
                    if (bidVol > 0) {
                        const bidHeight = (bidVol / maxVolume) * chartHeight;
                        const bidY = this.topMargin + chartHeight - bidHeight;
                        
                        // Bid volume color intensity based on volume
                        const bidIntensity = bidVol / maxVolume;
                        ctx.fillStyle = bidIntensity > 0.7 ? this.config.bidColorIntense : this.config.bidColor;
                        ctx.fillRect(x, bidY, barWidth, bidHeight);
                    }
                    
                    if (askVol > 0) {
                        const askHeight = (askVol / maxVolume) * chartHeight;
                        const askY = this.topMargin + chartHeight - askHeight;
                        
                        // Ask volume color intensity based on volume
                        const askIntensity = askVol / maxVolume;
                        ctx.fillStyle = askIntensity > 0.7 ? this.config.askColorIntense : this.config.askColor;
                        ctx.fillRect(x, askY, barWidth, askHeight);
                    }
                    
                    // Draw price labels for key levels
                    if (priceLabels && barIndex % Math.max(1, Math.floor(visibleLevels / 10)) === 0) {
                        const price = priceLabels[i];
                        if (price !== undefined) {
                            ctx.fillStyle = this.config.textColor;
                            ctx.font = '8px Courier New';
                            ctx.textAlign = 'center';
                            
                            const labelY = this.topMargin + chartHeight + 15;
                            ctx.fillText(price.toFixed(0), x + barWidth / 2, labelY);
                        }
                    }
                }
                
                // Draw mid price line
                if (midPrice && priceLabels) {
                    this.drawMidPriceLine(ctx, chartWidth, chartHeight, startLevel, endLevel, priceLabels, midPrice, barWidth);
                }
                
                // Draw axes labels
                this.drawAxesLabels(ctx, chartWidth, chartHeight, maxVolume);
                
                // Copy to main canvas
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }
            
            drawGrid(ctx, chartWidth, chartHeight, maxVolume) {
                ctx.strokeStyle = this.config.gridColor;
                ctx.lineWidth = 1;
                ctx.setLineDash([1, 1]);
                
                // Horizontal grid lines (volume levels)
                const numHLines = 5;
                for (let i = 0; i <= numHLines; i++) {
                    const y = this.topMargin + (i / numHLines) * chartHeight;
                    ctx.beginPath();
                    ctx.moveTo(this.leftMargin, y);
                    ctx.lineTo(this.leftMargin + chartWidth, y);
                    ctx.stroke();
                    
                    // Volume labels
                    const volume = maxVolume * (1 - i / numHLines);
                    ctx.fillStyle = '#666666';
                    ctx.font = '7px Courier New';
                    ctx.textAlign = 'right';
                    ctx.fillText(volume.toFixed(1), this.leftMargin - 5, y + 2);
                }
                
                ctx.setLineDash([]);
            }
            
            drawMidPriceLine(ctx, chartWidth, chartHeight, startLevel, endLevel, priceLabels, midPrice, barWidth) {
                // Find the bar index corresponding to mid price
                let midBarIndex = -1;
                for (let i = startLevel; i < endLevel; i++) {
                    if (priceLabels[i] && Math.abs(priceLabels[i] - midPrice) < 0.5) {
                        midBarIndex = i - startLevel;
                        break;
                    }
                }
                
                if (midBarIndex >= 0) {
                    const x = this.leftMargin + midBarIndex * (barWidth + this.config.barSpacing) + barWidth / 2;
                    
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    
                    ctx.beginPath();
                    ctx.moveTo(x, this.topMargin);
                    ctx.lineTo(x, this.topMargin + chartHeight);
                    ctx.stroke();
                    
                    // Mid price label
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '9px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('MID', x, this.topMargin - 5);
                    
                    ctx.setLineDash([]);
                }
            }
            
            drawAxesLabels(ctx, chartWidth, chartHeight, maxVolume) {
                ctx.fillStyle = this.config.textColor;
                ctx.font = '10px Courier New';
                
                // X-axis label
                ctx.textAlign = 'center';
                ctx.fillText('PRICE', this.leftMargin + chartWidth / 2, this.topMargin + chartHeight + 35);
                
                // Y-axis label (rotated)
                ctx.save();
                ctx.translate(15, this.topMargin + chartHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('VOLUME', 0, 0);
                ctx.restore();
            }
            
            redraw() {
                if (this.currentData) {
                    this.renderVolumeChart();
                } else {
                    this.clearCanvas();
                }
            }
            
            cleanup() {
                this.stopVisualization();
                this.offscreenCanvas = null;
                this.offscreenCtx = null;
                this.currentData = null;
            }
        }

        // Global simulation variables
        let Module = null;
        let simulation = null;
        let heatmapViz = null;
        let volumeChart = null;
        let isInitialized = false;
        let isRunning = false;
        let updateCount = 0;
        let spreadProfileCounter = 0;

        // Performance optimization - cached DOM elements and formatters
        const elements = {
            initBtn: document.getElementById('initBtn'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            resetBtn: document.getElementById('resetBtn'),
            simStatus: document.getElementById('simStatus'),
            queueSize: document.getElementById('queueSize'),
            updateCount: document.getElementById('updateCount'),
            currentSymbol: document.getElementById('currentSymbol'),
            l2UpdateCount: document.getElementById('l2UpdateCount'),
            midPrice: document.getElementById('midPrice'),
            spread: document.getElementById('spread'),
            activeAgents: document.getElementById('activeAgents'),
            spreadProfiles: document.getElementById('spreadProfiles'),
            addSpreadProfile: document.getElementById('addSpreadProfile'),
            askLevels: document.getElementById('askLevels'),
            bidLevels: document.getElementById('bidLevels'),
            error: document.getElementById('error'),
            errorMessage: document.getElementById('errorMessage')
        };

        // Optimized number formatting with caching
        const numberFormatCache = new Map();
        const priceFormatter = new Intl.NumberFormat('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        const quantityFormatter = new Intl.NumberFormat('en-US', {
            minimumFractionDigits: 4,
            maximumFractionDigits: 4
        });

        function formatPrice(price) {
            return priceFormatter.format(price);
        }

        function formatQuantity(quantity) {
            return quantityFormatter.format(quantity);
        }

        // Throttled update functions to prevent excessive DOM updates
        const throttleState = {
            lastStatusUpdate: 0,
            lastQueueUpdate: 0,
            statusUpdateInterval: 100, // ms
            queueUpdateInterval: 200   // ms
        };

        function throttledStatusUpdate(newStatus) {
            const now = Date.now();
            if (now - throttleState.lastStatusUpdate > throttleState.statusUpdateInterval) {
                elements.simStatus.textContent = newStatus;
                throttleState.lastStatusUpdate = now;
            }
        }

        function throttledQueueUpdate(queueSize) {
            const now = Date.now();
            if (now - throttleState.lastQueueUpdate > throttleState.queueUpdateInterval) {
                elements.queueSize.textContent = queueSize;
                throttleState.lastQueueUpdate = now;
            }
        }

        // Utility functions
        function toggleSection(header) {
            const section = header.parentElement;
            section.classList.toggle('collapsed');
        }

        function showError(message) {
            elements.error.classList.remove('hidden');
            elements.errorMessage.textContent = message;
            console.error('[System] Error:', message);
        }

        function hideError() {
            elements.error.classList.add('hidden');
        }

        function updateStatus(status) {
            throttledStatusUpdate(status);
            console.log('[System] Status:', status);
        }

        // Spread profile management
        function createSpreadProfile(profile = null) {
            const profileId = `profile_${++spreadProfileCounter}`;
            const defaultProfile = profile || {
                global_low: 1, global_high: 10,
                alpha_loc: 1.0, beta_loc: 1.0,
                alpha_wid: 1.0, beta_wid: 1.0, weight: 1.0
            };

            const profileHtml = `
                <div class="spread-profile" id="${profileId}">
                    <div class="spread-profile-header">
                        <div class="profile-title">PROFILE.${spreadProfileCounter}</div>
                        <button class="profile-remove" onclick="removeSpreadProfile('${profileId}')">×</button>
                    </div>
                    <div class="profile-grid">
                        <input class="profile-input" name="global_low" type="number" value="${defaultProfile.global_low}" min="1" max="1000" placeholder="LOW">
                        <input class="profile-input" name="global_high" type="number" value="${defaultProfile.global_high}" min="1" max="1000" placeholder="HIGH">
                        <input class="profile-input" name="alpha_loc" type="number" value="${defaultProfile.alpha_loc}" min="0.1" max="10" step="0.1" placeholder="A.LOC">
                        <input class="profile-input" name="beta_loc" type="number" value="${defaultProfile.beta_loc}" min="0.1" max="10" step="0.1" placeholder="B.LOC">
                        <input class="profile-input" name="alpha_wid" type="number" value="${defaultProfile.alpha_wid}" min="0.1" max="10" step="0.1" placeholder="A.WID">
                        <input class="profile-input" name="beta_wid" type="number" value="${defaultProfile.beta_wid}" min="0.1" max="10" step="0.1" placeholder="B.WID">
                    </div>
                    <input class="profile-input" name="weight" type="number" value="${defaultProfile.weight}" min="0.1" max="10" step="0.1" placeholder="WEIGHT" style="margin-top: 5px;">
                </div>
            `;

            elements.spreadProfiles.insertAdjacentHTML('beforeend', profileHtml);
        }

        function removeSpreadProfile(profileId) {
            const profile = document.getElementById(profileId);
            if (profile) profile.remove();
        }

        function getSpreadProfiles() {
            const profiles = [];
            const profileElements = elements.spreadProfiles.querySelectorAll('.spread-profile');
            
            profileElements.forEach(profileElement => {
                const inputs = profileElement.querySelectorAll('input');
                const profile = {};
                inputs.forEach(input => {
                    profile[input.name] = parseFloat(input.value);
                });
                profiles.push(profile);
            });
            
            return profiles;
        }

        function addPresetProfile(preset) {
            const presets = {
                'tight': { global_low: 1, global_high: 3, alpha_loc: 0.5, beta_loc: 4.0, alpha_wid: 0.8, beta_wid: 8.0, weight: 1.0 },
                'wide': { global_low: 20, global_high: 50, alpha_loc: 4.0, beta_loc: 0.5, alpha_wid: 8.0, beta_wid: 0.8, weight: 1.0 },
                'mixed': { global_low: 5, global_high: 15, alpha_loc: 1.5, beta_loc: 1.5, alpha_wid: 2.0, beta_wid: 2.0, weight: 1.0 }
            };
            
            if (presets[preset]) {
                createSpreadProfile(presets[preset]);
            }
        }

        // Input validation
        function validateInputs() {
            const errors = [];
            
            const agents = parseInt(document.getElementById('agents').value);
            if (agents < 1 || agents > 1000) {
                errors.push('Agents must be between 1 and 1000');
            }
            
            const profiles = getSpreadProfiles();
            if (profiles.length === 0) {
                errors.push('At least one spread profile required');
            }
            
            profiles.forEach((profile, index) => {
                if (profile.global_low >= profile.global_high) {
                    errors.push(`Profile ${index + 1}: Low must be < High`);
                }
                if (profile.weight <= 0) {
                    errors.push(`Profile ${index + 1}: Weight must be positive`);
                }
            });
            
            return errors;
        }

        // L2 order book callback
        function onL2Update(event) {
            updateCount++;
            elements.updateCount.textContent = updateCount;
            elements.l2UpdateCount.textContent = updateCount;
            elements.currentSymbol.textContent = event.symbol;

            // Calculate and display mid price and spread
            if (event.bids && event.bids.length > 0 && event.asks && event.asks.length > 0) {
                const midPrice = (event.bids[0].price + event.asks[0].price) / 2;
                const spread = event.asks[0].price - event.bids[0].price;
                
                elements.midPrice.textContent = formatPrice(midPrice);
                elements.spread.textContent = formatPrice(spread);
            }

            // Update orderbook display with optimized DOM manipulation
            updateOrderbookDisplay(event.asks, event.bids);

            // Update queue size with throttling
            if (simulation) {
                throttledQueueUpdate(simulation.getQueueSize());
            }

            // Forward to heatmap
            if (heatmapViz) {
                heatmapViz.onL2Update(event);
            }
        }

        // Optimized orderbook display with DOM element reuse
        const orderbookState = {
            askElements: [],
            bidElements: [],
            maxLevels: 20,
            elementPool: [],
            initialized: false
        };

        function initializeOrderbookElements() {
            if (orderbookState.initialized) return;
            
            // Pre-create DOM elements to avoid frequent creation/destruction
            for (let i = 0; i < orderbookState.maxLevels; i++) {
                const askElement = createOrderbookLevel();
                const bidElement = createOrderbookLevel();
                
                orderbookState.askElements.push(askElement);
                orderbookState.bidElements.push(bidElement);
                
                elements.askLevels.appendChild(askElement);
                elements.bidLevels.appendChild(bidElement);
            }
            
            orderbookState.initialized = true;
        }

        function createOrderbookLevel() {
            const level = document.createElement('div');
            level.className = 'orderbook-level';
            level.style.display = 'none'; // Initially hidden
            
            const price = document.createElement('div');
            price.className = 'price';
            
            const quantity = document.createElement('div');
            quantity.className = 'quantity';
            
            level.appendChild(price);
            level.appendChild(quantity);
            
            return level;
        }

        function updateOrderbookDisplay(asks, bids) {
            if (!orderbookState.initialized) {
                initializeOrderbookElements();
            }

            // Update asks (reversed order for display)
            const reversedAsks = asks.slice().reverse();
            updateOrderbookSide(reversedAsks, orderbookState.askElements);
            
            // Update bids
            updateOrderbookSide(bids, orderbookState.bidElements);
        }

        function updateOrderbookSide(levels, domElements) {
            const numLevels = Math.min(levels.length, domElements.length);
            
            // Update visible levels
            for (let i = 0; i < numLevels; i++) {
                const level = levels[i];
                const element = domElements[i];
                
                // Update content using optimized formatters
                element.children[0].textContent = formatPrice(level.price);
                element.children[1].textContent = formatQuantity(level.quantity);
                element.style.display = 'grid';
            }
            
            // Hide unused elements
            for (let i = numLevels; i < domElements.length; i++) {
                domElements[i].style.display = 'none';
            }
        }

        // Heatmap callback
        function onHeatmapUpdate(heatmapData) {
            if (heatmapViz) {
                heatmapViz.onHeatmapUpdate(heatmapData);
            }
            
            // Also update volume chart with current data
            if (volumeChart) {
                volumeChart.onVolumeUpdate(heatmapData);
            }
        }

        // Simulation control functions
        function initializeSimulation() {
            hideError();
            
            if (!Module || !Module.ExchangeSimulation) {
                showError('WebAssembly module not loaded');
                return;
            }

            const validationErrors = validateInputs();
            if (validationErrors.length > 0) {
                showError('Validation errors:\n• ' + validationErrors.join('\n• '));
                return;
            }

            try {
                if (simulation) {
                    simulation.cleanup();
                    simulation.delete();
                }

                simulation = new Module.ExchangeSimulation();

                // Configure parameters
                simulation.setAgents(parseInt(document.getElementById('agents').value));
                simulation.setSymbol(document.getElementById('symbol').value);
                simulation.setSeed(parseInt(document.getElementById('seed').value));
                simulation.setSpeedFactor(parseFloat(document.getElementById('speedFactor').value));

                // Timeout parameters
                simulation.setTimeoutDistribution(document.getElementById('timeoutDist').value);
                simulation.setMedianTimeoutSeconds(parseFloat(document.getElementById('medianTimeout').value));
                simulation.setSigmaTimeout(parseFloat(document.getElementById('sigmaTimeout').value));
                simulation.setParetoAlpha(parseFloat(document.getElementById('paretoAlpha').value));
                simulation.setParetoScale(parseFloat(document.getElementById('paretoScale').value));
                simulation.setTailMix(parseFloat(document.getElementById('tailMix').value));
                simulation.setMinTimeoutS(parseFloat(document.getElementById('minTimeoutS').value));
                simulation.setMaxTimeoutS(parseFloat(document.getElementById('maxTimeoutS').value));

                // Order sizes
                simulation.setOrderSizeRanges(
                    parseFloat(document.getElementById('minSizeMin').value),
                    parseFloat(document.getElementById('minSizeMax').value),
                    parseFloat(document.getElementById('maxSizeMin').value),
                    parseFloat(document.getElementById('maxSizeMax').value)
                );

                // Imbalance parameters
                simulation.setImbalanceParams(
                    parseInt(document.getElementById('imbalanceLevelsMin').value),
                    parseInt(document.getElementById('imbalanceLevelsMax').value),
                    parseInt(document.getElementById('maxImbalanceAdjMin').value),
                    parseInt(document.getElementById('maxImbalanceAdjMax').value)
                );

                // Advanced settings
                simulation.setWarmupRangeMs(
                    parseInt(document.getElementById('warmupMin').value),
                    parseInt(document.getElementById('warmupMax').value)
                );
                simulation.setOrderBookSeedLevels(parseInt(document.getElementById('seedLevels').value));

                // Spread profiles
                simulation.clearSpreadProfiles();
                const spreadProfiles = getSpreadProfiles();
                spreadProfiles.forEach(profile => {
                    simulation.addSpreadProfile(
                        profile.global_low, profile.global_high,
                        profile.alpha_loc, profile.beta_loc,
                        profile.alpha_wid, profile.beta_wid,
                        profile.weight
                    );
                });

                // Set callbacks
                simulation.setL2Callback(onL2Update);
                simulation.setHeatmapCallback(onHeatmapUpdate);

                // Heatmap configuration
                if (simulation.setHeatmapBufferSize) {
                    simulation.setHeatmapBufferSize(parseInt(document.getElementById('heatmapBufferSize').value));
                }
                if (simulation.setHeatmapFrequency) {
                    simulation.setHeatmapFrequency(parseInt(document.getElementById('heatmapUpdateFreq').value));
                }
                if (simulation.setHeatmapUpdates) {
                    simulation.setHeatmapUpdates(document.getElementById('heatmapEnabled').checked);
                }

                // Initialize
                const success = simulation.initialize();
                if (!success) {
                    throw new Error('Failed to initialize simulation');
                }

                isInitialized = true;
                updateStatus('READY');
                elements.startBtn.disabled = false;
                elements.activeAgents.textContent = document.getElementById('agents').value;

            } catch (error) {
                showError(`Initialization failed: ${error.message}`);
                isInitialized = false;
            }
        }

        function startSimulation() {
            if (!isInitialized || isRunning) return;

            try {
                updateStatus('STARTING');
                const success = simulation.start();
                
                if (success) {
                    isRunning = true;
                    updateStatus('RUNNING');
                    elements.startBtn.disabled = true;
                    elements.stopBtn.disabled = false;
                    elements.initBtn.disabled = true;
                    
                    // Start heatmap visualization with real data
                    if (heatmapViz) {
                        heatmapViz.startVisualization(true); // true = use real data from WebAssembly
                    }
                    
                    // Start volume chart visualization
                    if (volumeChart) {
                        volumeChart.startVisualization();
                    }
                    
                    // Optimized monitoring with less frequent polling
                    let lastQueueSize = -1;
                    const monitor = setInterval(() => {
                        if (!isRunning) {
                            clearInterval(monitor);
                            return;
                        }
                        
                        const queueSize = simulation.getQueueSize();
                        
                        // Only update if queue size changed
                        if (queueSize !== lastQueueSize) {
                            throttledQueueUpdate(queueSize);
                            lastQueueSize = queueSize;
                        }
                        
                        if (queueSize === 0) {
                            stopSimulation();
                            updateStatus('COMPLETE');
                        }
                    }, 250); // Reduced from 100ms to 250ms
                } else {
                    throw new Error('Failed to start simulation');
                }
            } catch (error) {
                showError(`Start failed: ${error.message}`);
                updateStatus('ERROR');
            }
        }

        function stopSimulation() {
            if (!isRunning) return;

            try {
                simulation.stop();
                isRunning = false;
                updateStatus('STOPPED');
                elements.startBtn.disabled = false;
                elements.stopBtn.disabled = true;
                elements.initBtn.disabled = false;
                
                // Stop heatmap visualization
                if (heatmapViz) {
                    heatmapViz.stopVisualization();
                }
                
                // Stop volume chart visualization
                if (volumeChart) {
                    volumeChart.stopVisualization();
                }
            } catch (error) {
                showError(`Stop failed: ${error.message}`);
            }
        }

        function resetToDefaults() {
            // Stop any running processes first
            if (isRunning) {
                stopSimulation();
            }
            
            // Reset heatmap visualization
            if (heatmapViz) {
                heatmapViz.stopVisualization();
                heatmapViz.dataBuffer = []; // Clear data buffer
                heatmapViz.updateCount = 0;
                heatmapViz.clearCanvas();
                
                // Reset heatmap UI counters
                document.getElementById('heatmapUpdateCount').textContent = '0';
                document.getElementById('heatmapBufferUsage').textContent = '0';
            }
            
            // Reset volume chart visualization
            if (volumeChart) {
                volumeChart.stopVisualization();
                volumeChart.currentData = null;
                volumeChart.clearCanvas();
                
                // Reset volume chart UI
                document.getElementById('volumeChartLevels').textContent = '0';
                document.getElementById('volumeChartMaxVol').textContent = '0.000';
                document.getElementById('volumeChartMidPrice').textContent = '0.00';
            }
            
            // Reset performance states
            throttleState.lastStatusUpdate = 0;
            throttleState.lastQueueUpdate = 0;
            numberFormatCache.clear();
            
            // Reset orderbook display efficiently
            if (orderbookState.initialized) {
                orderbookState.askElements.forEach(el => el.style.display = 'none');
                orderbookState.bidElements.forEach(el => el.style.display = 'none');
            }
            
            // Reset form values
            document.getElementById('agents').value = 10;
            document.getElementById('symbol').value = 'BTC/USD';
            document.getElementById('seed').value = 47;
            document.getElementById('speedFactor').value = 100;
            
            document.getElementById('timeoutDist').value = 'lognormal';
            document.getElementById('medianTimeout').value = 5;
            document.getElementById('sigmaTimeout').value = 0.8;
            document.getElementById('paretoAlpha').value = 1.5;
            document.getElementById('paretoScale').value = 5;
            document.getElementById('tailMix').value = 0.1;
            document.getElementById('minTimeoutS').value = 1;
            document.getElementById('maxTimeoutS').value = 60;
            
            document.getElementById('minSizeMin').value = 0.01;
            document.getElementById('minSizeMax').value = 0.1;
            document.getElementById('maxSizeMin').value = 0.1;
            document.getElementById('maxSizeMax').value = 0.5;
            
            document.getElementById('imbalanceLevelsMin').value = 1;
            document.getElementById('imbalanceLevelsMax').value = 3;
            document.getElementById('maxImbalanceAdjMin').value = 2;
            document.getElementById('maxImbalanceAdjMax').value = 10;
            
            document.getElementById('warmupMin').value = 0;
            document.getElementById('warmupMax').value = 0;
            document.getElementById('seedLevels').value = 5;
            
            document.getElementById('heatmapBufferSize').value = 300;
            document.getElementById('heatmapUpdateFreq').value = 5;
            document.getElementById('heatmapIntensity').value = 3;
            document.getElementById('heatmapEnabled').checked = true;
            
            // Reset simulation state
            isInitialized = false;
            isRunning = false;
            updateCount = 0;
            
            // Reset UI state
            elements.startBtn.disabled = true;
            elements.stopBtn.disabled = true;
            elements.initBtn.disabled = false;
            elements.updateCount.textContent = '0';
            elements.l2UpdateCount.textContent = '0';
            elements.queueSize.textContent = '0';
            elements.midPrice.textContent = '0.00';
            elements.spread.textContent = '0.00';
            elements.activeAgents.textContent = '0';
            elements.currentSymbol.textContent = '-';
            
            // Reset spread profiles
            initializeDefaultSpreadProfiles();
            
            // Update status
            if (Module) {
                updateStatus('LOADED');
            } else {
                updateStatus('DEMO MODE');
                // Re-enable demo mode if no WebAssembly
                if (heatmapViz) {
                    heatmapViz.startVisualization(false);
                }
                if (volumeChart) {
                    volumeChart.startVisualization();
                }
            }
            
            hideError();
            console.log('[System] Reset to defaults');
        }

        function initializeDefaultSpreadProfiles() {
            elements.spreadProfiles.innerHTML = '';
            spreadProfileCounter = 0;
            
            createSpreadProfile({ global_low: 1, global_high: 5, alpha_loc: 0.7, beta_loc: 3.0, alpha_wid: 1.0, beta_wid: 6.0, weight: 0.5 });
            createSpreadProfile({ global_low: 50, global_high: 100, alpha_loc: 3.0, beta_loc: 0.7, alpha_wid: 6.0, beta_wid: 1.0, weight: 0.5 });
        }

        // Event listeners
        elements.initBtn.addEventListener('click', initializeSimulation);
        elements.startBtn.addEventListener('click', startSimulation);
        elements.stopBtn.addEventListener('click', stopSimulation);
        elements.resetBtn.addEventListener('click', resetToDefaults);
        elements.addSpreadProfile.addEventListener('click', () => createSpreadProfile());

        // Initialize system
        function loadModule() {
            console.log('[System] Loading WebAssembly module...');
            
            if (typeof ExchangeSimulationModule === 'undefined') {
                console.log('[System] WebAssembly module not found, starting demo mode');
                startDemoMode();
                return;
            }

            ExchangeSimulationModule().then(module => {
                Module = module;
                console.log('[System] WebAssembly module loaded');
                
                // Initialize heatmap visualization
                heatmapViz = new OrderbookHeatmap();
                
                // Initialize volume chart
                volumeChart = new VolumeBarplot();
                
                // Initialize default profiles
                initializeDefaultSpreadProfiles();
                
                updateStatus('LOADED');
                
            }).catch(error => {
                console.log('[System] WebAssembly loading failed, starting demo mode');
                startDemoMode();
            });
        }

        function startDemoMode() {
            console.log('[System] Starting demo mode with synthetic data');
            
            // Initialize heatmap visualization
            heatmapViz = new OrderbookHeatmap();
            
            // Initialize volume chart
            volumeChart = new VolumeBarplot();
            
            // Initialize default profiles (for display purposes)
            initializeDefaultSpreadProfiles();
            
            updateStatus('DEMO MODE');
            
            // Disable WebAssembly-dependent controls
            elements.initBtn.disabled = true;
            elements.startBtn.disabled = true;
            elements.stopBtn.disabled = true;
            
            // Start synthetic heatmap data for demo
            heatmapViz.startVisualization(false); // false = use synthetic data
            
            // Start volume chart in demo mode
            volumeChart.startVisualization();
            
            // Show demo message
            showError('Demo Mode: WebAssembly not available. Showing synthetic heatmap data only.');
        }

        // Auto-load when page is ready
        window.addEventListener('load', () => {
            setTimeout(loadModule, 100);
        });

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (simulation) {
                simulation.cleanup();
                simulation.delete();
            }
            if (heatmapViz) {
                heatmapViz.cleanup();
            }
            if (volumeChart) {
                volumeChart.cleanup();
            }
        });

        // Keyboard shortcuts for Ikeda-style control
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.code) {
                case 'KeyI':
                    if (!isInitialized) initializeSimulation();
                    break;
                case 'Space':
                    e.preventDefault();
                    if (isInitialized && !isRunning) startSimulation();
                    else if (isRunning) stopSimulation();
                    break;
                case 'KeyR':
                    if (e.ctrlKey || e.metaKey) return;
                    e.preventDefault();
                    resetToDefaults();
                    break;
                case 'Escape':
                    if (isRunning) stopSimulation();
                    break;
            }
        });
    </script>

    <!-- Load WebAssembly module -->
    <script src="exchange_simulation.js"></script>
</body>
</html> 