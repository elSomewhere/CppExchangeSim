<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L2 3D Orderbook Tracer Demo</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #0d1117;
            color: #c9d1d9;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            height: 90vh;
        }

        .panel {
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .button-start {
            background: #238636;
            color: white;
        }

        .button-stop {
            background: #da3633;
            color: white;
        }

        .button-reset {
            background: #1f6feb;
            color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: #0d1117;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #30363d;
        }

        .stat-label {
            color: #8b949e;
            font-size: 12px;
        }

        .stat-value {
            color: #58a6ff;
            font-weight: 600;
        }

        .voxel-list {
            height: 400px;
            overflow-y: auto;
            font-size: 11px;
        }

        .voxel-item {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            border-left: 3px solid;
        }

        .voxel-bid {
            border-left-color: #7ee787;
            background: rgba(46, 160, 67, 0.1);
        }

        .voxel-ask {
            border-left-color: #ff7b72;
            background: rgba(248, 81, 73, 0.1);
        }

        .voxel-active {
            opacity: 1.0;
        }

        .voxel-historical {
            opacity: 0.6;
        }

        .log {
            height: 200px;
            overflow-y: auto;
            background: #0d1117;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #30363d;
            font-size: 11px;
        }

        .control-group {
            margin-bottom: 8px;
        }
        .control-label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #c9d1d9;
        }
        .control-input {
            width: 100%;
        }
        .control-hint {
            font-size: 10px;
            color: #8b949e;
        }
    </style>
</head>

<body>
    <h1>L2 Orderbook 3D Tracer Demo</h1>

    <div class="container">
        <div class="panel">
            <h2>3D Voxel Visualization</h2>
            <div id="threejs-container"
                style="width: 100%; height: 300px; border: 1px solid #30363d; border-radius: 4px; background: #000;">
            </div>

            <div style="margin-top: 15px;">
                <h3 style="color: #58a6ff; font-size: 14px; margin-bottom: 10px;">Axis Scaling Controls</h3>
                <div class="control-group">
                    <label class="control-label">Price Scale (X): <span id="priceScaleValue">10</span>x</label>
                    <input type="range" id="priceScale" class="control-input" min="1" max="100" step="1" value="10">
                    <div class="control-hint">1x - 100x scaling</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Volume Scale (Y): <span id="volumeScaleValue">0.5</span>x</label>
                    <input type="range" id="volumeScale" class="control-input" min="0.1" max="5" step="0.1" value="0.5">
                    <div class="control-hint">0.1x - 5x scaling</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Time Scale (Z): <span id="timeScaleValue">0.01</span>x</label>
                    <input type="range" id="timeScale" class="control-input" min="0.001" max="0.1" step="0.001"
                        value="0.01">
                    <div class="control-hint">0.001x - 0.1x scaling</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Voxel Width: <span id="voxelWidthValue">0.5</span></label>
                    <input type="range" id="voxelWidth" class="control-input" min="0.1" max="5" step="0.1" value="0.5">
                    <div class="control-hint">Individual voxel thickness</div>
                </div>
                <div class="control-group">
                    <label class="control-label">FPS: <span id="fpsValue">30</span></label>
                    <input type="range" id="fpsControl" class="control-input" min="1" max="60" step="1" value="30">
                    <div class="control-hint">1 - 60 frames / second</div>
                </div>
            </div>

            <div style="margin-top: 10px; font-size: 11px; color: #8b949e;">
                <strong>Controls:</strong> Mouse to rotate • Scroll to zoom •
                <strong>Axes:</strong> X=Price, Y=Volume, Z=Time
            </div>
        </div>

        <div class="panel">
            <h2>L2 Generator & Controls</h2>

            <div class="controls">
                <button id="startBtn" class="button button-start">Start</button>
                <button id="stopBtn" class="button button-stop">Stop</button>
                <button id="resetBtn" class="button button-reset">Reset</button>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">L2 Events</div>
                    <div class="stat-value" id="l2Events">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Event Rate</div>
                    <div class="stat-value" id="eventRate">0.0/s</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Active Voxels</div>
                    <div class="stat-value" id="activeVoxels">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Historical Voxels</div>
                    <div class="stat-value" id="historicalVoxels">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Created</div>
                    <div class="stat-value" id="totalVoxels">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Current Time</div>
                    <div class="stat-value" id="currentTime">0</div>
                </div>
            </div>

            <h3>Event Log</h3>
            <div class="log" id="eventLog"></div>
        </div>

        <div class="panel">
            <h2>Voxel State Details</h2>
            <p style="color: #8b949e; font-size: 12px;">
                Text representation of the voxel objects being rendered in 3D.
                Each voxel represents a price-volume-time block.
            </p>

            <div class="voxel-list" id="voxelList"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 3D Voxel Renderer using Three.js
        class VoxelRenderer3D {
            constructor(containerElement) {
                this.container = containerElement;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, containerElement.clientWidth / containerElement.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });

                this.voxelMeshes = new Map(); // voxel ID -> mesh
                this.timeOffset = 0; // For time axis positioning
                this.priceOffset = 100; // Center price around 0

                // Scaling factors for each axis
                this.scales = {
                    price: 10,    // X-axis scaling
                    volume: 0.5,  // Y-axis scaling  
                    time: 0.01,   // Z-axis scaling
                    voxelWidth: 0.5 // Individual voxel width
                };

                this.init();
            }

            setScales(priceScale, volumeScale, timeScale, voxelWidth) {
                this.scales.price = priceScale;
                this.scales.volume = volumeScale;
                this.scales.time = timeScale;
                this.scales.voxelWidth = voxelWidth;
            }

            init() {
                // Setup renderer
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setClearColor(0x0d1117);
                this.container.appendChild(this.renderer.domElement);

                // Setup camera
                this.camera.position.set(50, 50, 50);
                this.camera.lookAt(0, 0, 0);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                this.scene.add(directionalLight);

                // Add axes helper with labels
                const axesHelper = new THREE.AxesHelper(20);
                this.scene.add(axesHelper);

                // Add price axis labels (simplified)
                this.addAxisLabel('Price →', 25, 0, 0, 0x58a6ff);
                this.addAxisLabel('Volume ↑', 0, 25, 0, 0x58a6ff);
                this.addAxisLabel('Time →', 0, 0, 25, 0x58a6ff);

                // Add grid
                const gridHelper = new THREE.GridHelper(100, 20, 0x333333, 0x333333);
                this.scene.add(gridHelper);

                // Add simple orbit controls (mouse interaction)
                this.setupControls();

                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            addAxisLabel(text, x, y, z, color) {
                // Create a simple text sprite (placeholder - in real implementation you'd use proper text rendering)
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.font = '16px Arial';
                context.fillText(text, 10, 30);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y, z);
                sprite.scale.set(10, 2.5, 1);
                this.scene.add(sprite);
            }

            setupControls() {
                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;

                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;

                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;

                    // Rotate camera around the scene
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(this.camera.position);
                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                    this.camera.position.setFromSpherical(spherical);
                    this.camera.lookAt(0, 0, 0);

                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                this.renderer.domElement.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                this.renderer.domElement.addEventListener('wheel', (e) => {
                    const distance = this.camera.position.length();
                    const newDistance = distance + e.deltaY * 0.1;
                    this.camera.position.normalize().multiplyScalar(Math.max(10, Math.min(200, newDistance)));
                });
            }

            updateVoxels(voxelData) {
                const currentTime = voxelData.currentTime;

                // Update time offset to keep recent voxels in view
                this.timeOffset = currentTime - 5000; // Show last 5 seconds

                // Track which voxels are still active
                const activeVoxelIds = new Set();

                // Update active voxels
                voxelData.active.forEach(voxel => {
                    activeVoxelIds.add(voxel.id);
                    this.updateVoxelMesh(voxel, currentTime);
                });

                // Update recent historical voxels (last 50)
                const recentHistorical = voxelData.historical.slice(-50);
                recentHistorical.forEach(voxel => {
                    if (voxel.endTime > this.timeOffset) { // Only show recent history
                        activeVoxelIds.add(voxel.id);
                        this.updateVoxelMesh(voxel, currentTime);
                    }
                });

                // Remove old voxel meshes
                for (const [voxelId, mesh] of this.voxelMeshes) {
                    if (!activeVoxelIds.has(voxelId)) {
                        this.scene.remove(mesh);
                        this.voxelMeshes.delete(voxelId);
                    }
                }
            }

            updateVoxelMesh(voxel, currentTime) {
                let mesh = this.voxelMeshes.get(voxel.id);

                if (!mesh) {
                    // Create new mesh
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const bidColor = new THREE.Color(0x7ee787); // Green for bids
                    const askColor = new THREE.Color(0xff7b72); // Red for asks

                    const material = new THREE.MeshLambertMaterial({
                        color: voxel.side === 'bid' ? bidColor : askColor,
                        transparent: true,
                        opacity: voxel.isActive ? 0.8 : 0.4,
                        emissive: voxel.side === 'bid' ?
                            new THREE.Color(0x0a4a1a) : new THREE.Color(0x4a0a0a),
                        emissiveIntensity: 0.2
                    });

                    mesh = new THREE.Mesh(geometry, material);
                    this.scene.add(mesh);
                    this.voxelMeshes.set(voxel.id, mesh);
                }

                // Update position and scale
                const x = (voxel.price - this.priceOffset) * this.scales.price;
                const y = voxel.volume * this.scales.volume;
                const z = (voxel.startTime - this.timeOffset) * this.scales.time;

                // Calculate dimensions
                const width = this.scales.voxelWidth; // Configurable width for price levels
                const height = voxel.volume * this.scales.volume; // Height represents volume
                const depth = Math.max(0.1, voxel.duration * this.scales.time); // Depth represents time duration

                mesh.position.set(x, y / 2, z + depth / 2); // Position at base of volume
                mesh.scale.set(width, height, depth);

                // Update material opacity for active vs historical
                mesh.material.opacity = voxel.isActive ? 0.8 : 0.4;
            }

            render() {
                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }

        // Include the L2OrderbookTracer class from the previous artifact
        class L2OrderbookTracer {
            constructor(config = {}) {
                this.config = {
                    priceResolution: 0.001,
                    maxPriceLevels: 100,
                    timeResolution: 0.016,
                    maxTimeSlices: 1000,
                    volumeThreshold: 0.1,
                    ...config
                };

                this.currentState = new Map();
                this.activeVoxels = new Map();
                this.historicalVoxels = [];
                this.eventBuffer = [];
                this.currentTime = 0;
                this.lastFrameTime = 0;
                this.nextVoxelId = 0;
            }

            addL2Event(snapshot) {
                this.eventBuffer.push({
                    timestamp: snapshot.timestamp,
                    bids: [...snapshot.bids],
                    asks: [...snapshot.asks]
                });
            }

            processEventsForFrame(currentFrameTime) {
                this.currentTime = currentFrameTime;
                const deltaTime = currentFrameTime - this.lastFrameTime;

                this.extendActiveVoxels(deltaTime);

                while (this.eventBuffer.length > 0) {
                    const event = this.eventBuffer.shift();
                    this.processL2Event(event);
                }

                this.lastFrameTime = currentFrameTime;
            }

            extendActiveVoxels(deltaTime) {
                for (const voxel of this.activeVoxels.values()) {
                    voxel.duration += deltaTime;
                    voxel.endTime = this.currentTime;
                }
            }

            processL2Event(event) {
                const newState = new Map();

                for (const bid of event.bids) {
                    const priceKey = this.getPriceKey(bid.price);
                    newState.set(`bid_${priceKey}`, {
                        side: 'bid',
                        price: bid.price,
                        volume: bid.size,
                        timestamp: event.timestamp
                    });
                }

                for (const ask of event.asks) {
                    const priceKey = this.getPriceKey(ask.price);
                    newState.set(`ask_${priceKey}`, {
                        side: 'ask',
                        price: ask.price,
                        volume: ask.size,
                        timestamp: event.timestamp
                    });
                }

                this.updateVoxelsFromStateChange(newState, event.timestamp);
                this.currentState = newState;
            }

            updateVoxelsFromStateChange(newState, timestamp) {
                const stillActive = new Set();

                for (const [key, newLevel] of newState) {
                    const currentLevel = this.currentState.get(key);

                    if (!currentLevel ||
                        Math.abs(currentLevel.volume - newLevel.volume) > this.config.volumeThreshold) {

                        if (this.activeVoxels.has(key)) {
                            this.finalizeVoxel(key, timestamp);
                        }

                        if (newLevel.volume > this.config.volumeThreshold) {
                            this.createNewVoxel(key, newLevel, timestamp);
                            stillActive.add(key);
                        }
                    } else {
                        stillActive.add(key);
                    }
                }

                for (const key of this.activeVoxels.keys()) {
                    if (!stillActive.has(key)) {
                        this.finalizeVoxel(key, timestamp);
                    }
                }
            }

            createNewVoxel(key, level, timestamp) {
                const voxel = {
                    id: this.nextVoxelId++,
                    key: key,
                    side: level.side,
                    price: level.price,
                    volume: level.volume,
                    startTime: timestamp,
                    endTime: timestamp,
                    duration: 0,
                    isActive: true
                };

                this.activeVoxels.set(key, voxel);
                this.logEvent(`Created voxel ${voxel.id}: ${level.side} $${level.price.toFixed(3)} vol=${level.volume.toFixed(1)}`);
            }

            finalizeVoxel(key, timestamp) {
                const voxel = this.activeVoxels.get(key);
                if (voxel) {
                    voxel.isActive = false;
                    voxel.endTime = timestamp;
                    this.historicalVoxels.push(voxel);
                    this.activeVoxels.delete(key);
                    this.logEvent(`Finalized voxel ${voxel.id}: duration=${voxel.duration.toFixed(0)}ms`);
                }
            }

            getPriceKey(price) {
                return Math.round(price / this.config.priceResolution) * this.config.priceResolution;
            }

            getAllVoxels() {
                return {
                    active: Array.from(this.activeVoxels.values()),
                    historical: this.historicalVoxels,
                    currentTime: this.currentTime
                };
            }

            getStats() {
                return {
                    activeVoxels: this.activeVoxels.size,
                    historicalVoxels: this.historicalVoxels.length,
                    eventsInBuffer: this.eventBuffer.length,
                    currentTime: this.currentTime,
                    totalVoxelsCreated: this.nextVoxelId
                };
            }

            cleanupOldVoxels(timeWindow) {
                const cutoffTime = this.currentTime - timeWindow;
                this.historicalVoxels = this.historicalVoxels.filter(
                    voxel => voxel.endTime > cutoffTime
                );
            }

            logEvent(message) {
                const log = document.getElementById('eventLog');
                if (log) {
                    const timestamp = new Date().toLocaleTimeString();
                    log.innerHTML += `<div style="color: #58a6ff;">[${timestamp}] ${message}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
            }
        }

        // Demo Application
        class TracerDemo {
            constructor() {
                // Use Web Worker for background L2 generation
                this.worker = new Worker('l2GeneratorWorker.js');
                this.eventCount = 0;
                this.targetFps = 30;
                this.lastRenderTime = 0;
                this.tracer = new L2OrderbookTracer({
                    priceResolution: 0.01,
                    volumeThreshold: 1.0
                });

                this.renderer3D = new VoxelRenderer3D(document.getElementById('threejs-container'));

                this.frameCount = 0;
                this.isRunning = false;

                this.setupCallbacks();
                this.setupUI();
                this.startAnimationLoop();

                // Initialize scaling control displays
                this.initializeScalingDisplays();
            }

            initializeScalingDisplays() {
                document.getElementById('priceScaleValue').textContent = '10';
                document.getElementById('volumeScaleValue').textContent = '0.5';
                document.getElementById('timeScaleValue').textContent = '0.010';
                document.getElementById('voxelWidthValue').textContent = '0.5';
                document.getElementById('fpsValue').textContent = '30';
            }

            setupCallbacks() {
                this.worker.onmessage = (event) => {
                    if (event.data.type === 'snapshot') {
                        this.eventCount++;
                        this.tracer.addL2Event(event.data.snapshot);
                    }
                };
            }

            setupUI() {
                document.getElementById('startBtn').onclick = () => {
                    this.worker.postMessage({ type: 'start' });
                    this.isRunning = true;
                };

                document.getElementById('stopBtn').onclick = () => {
                    this.worker.postMessage({ type: 'stop' });
                    this.isRunning = false;
                };

                document.getElementById('resetBtn').onclick = () => {
                    this.worker.postMessage({ type: 'reset' });
                    this.isRunning = false;
                    this.eventCount = 0;
                    this.tracer = new L2OrderbookTracer({
                        priceResolution: 0.01,
                        volumeThreshold: 1.0
                    });

                    // Clear 3D scene
                    for (const [voxelId, mesh] of this.renderer3D.voxelMeshes) {
                        this.renderer3D.scene.remove(mesh);
                    }
                    this.renderer3D.voxelMeshes.clear();

                    this.setupCallbacks();
                };

                // Setup scaling controls
                this.setupScalingControls();

                // FPS control
                this.setupFpsControl();
            }

            setupScalingControls() {
                const scalingControls = [
                    { id: 'priceScale', valueId: 'priceScaleValue', suffix: 'x' },
                    { id: 'volumeScale', valueId: 'volumeScaleValue', suffix: 'x' },
                    { id: 'timeScale', valueId: 'timeScaleValue', suffix: 'x' },
                    { id: 'voxelWidth', valueId: 'voxelWidthValue', suffix: '' }
                ];

                scalingControls.forEach(control => {
                    const slider = document.getElementById(control.id);
                    const valueDisplay = document.getElementById(control.valueId);

                    if (slider && valueDisplay) {
                        slider.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            valueDisplay.textContent = value.toFixed(3) + control.suffix;
                            this.updateScaling();
                        });
                    }
                });
            }

            setupFpsControl() {
                const fpsSlider = document.getElementById('fpsControl');
                const fpsValue = document.getElementById('fpsValue');

                if (fpsSlider && fpsValue) {
                    fpsSlider.addEventListener('input', (e) => {
                        this.targetFps = parseInt(e.target.value, 10);
                        fpsValue.textContent = this.targetFps;
                    });
                }
            }

            updateScaling() {
                const priceScale = parseFloat(document.getElementById('priceScale').value);
                const volumeScale = parseFloat(document.getElementById('volumeScale').value);
                const timeScale = parseFloat(document.getElementById('timeScale').value);
                const voxelWidth = parseFloat(document.getElementById('voxelWidth').value);

                this.renderer3D.setScales(priceScale, volumeScale, timeScale, voxelWidth);
            }

            startAnimationLoop() {
                const animate = (timestamp) => {
                    if (timestamp - this.lastRenderTime >= 1000 / this.targetFps) {
                        this.lastRenderTime = timestamp;
                        this.frameCount++;

                        const currentTime = performance.now();

                        // Process events for this frame (batching)
                        this.tracer.processEventsForFrame(currentTime);

                        // Update 3D visualization
                        const voxelData = this.tracer.getAllVoxels();
                        this.renderer3D.updateVoxels(voxelData);
                        this.renderer3D.render();

                        // Update UI every 10 frames
                        if (this.frameCount % 10 === 0) {
                            this.updateUI();
                        }

                        // Cleanup old voxels every 60 frames
                        if (this.frameCount % 60 === 0) {
                            this.tracer.cleanupOldVoxels(10000); // 10 second window
                        }
                    }

                    requestAnimationFrame(animate);
                };

                requestAnimationFrame(animate);
            }

            updateUI() {
                const tracerStats = this.tracer.getStats();

                document.getElementById('l2Events').textContent = this.eventCount;
                document.getElementById('eventRate').textContent = this.isRunning ? '10.0/s' : '0.0/s';
                document.getElementById('activeVoxels').textContent = tracerStats.activeVoxels;
                document.getElementById('historicalVoxels').textContent = tracerStats.historicalVoxels;
                document.getElementById('totalVoxels').textContent = tracerStats.totalVoxelsCreated;
                document.getElementById('currentTime').textContent = Math.round(tracerStats.currentTime);

                this.updateVoxelList();
            }

            updateVoxelList() {
                const voxelData = this.tracer.getAllVoxels();
                const container = document.getElementById('voxelList');

                container.innerHTML = '';

                // Show active voxels first
                voxelData.active.forEach(voxel => {
                    const div = document.createElement('div');
                    div.className = `voxel-item voxel-${voxel.side} voxel-active`;
                    div.innerHTML = `
                        <strong>Active #${voxel.id}</strong> 
                        ${voxel.side.toUpperCase()} $${voxel.price.toFixed(3)} 
                        vol=${voxel.volume.toFixed(1)} 
                        duration=${voxel.duration.toFixed(0)}ms
                    `;
                    container.appendChild(div);
                });

                // Show recent historical voxels
                const recentHistorical = voxelData.historical
                    .slice(-20)
                    .reverse();

                recentHistorical.forEach(voxel => {
                    const div = document.createElement('div');
                    div.className = `voxel-item voxel-${voxel.side} voxel-historical`;
                    div.innerHTML = `
                        <strong>Historical #${voxel.id}</strong> 
                        ${voxel.side.toUpperCase()} $${voxel.price.toFixed(3)} 
                        vol=${voxel.volume.toFixed(1)} 
                        lived=${voxel.duration.toFixed(0)}ms
                    `;
                    container.appendChild(div);
                });
            }
        }

        // Start the demo
        window.addEventListener('load', () => {
            new TracerDemo();
        });
    </script>
</body>

</html>